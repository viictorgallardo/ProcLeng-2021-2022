//*****************************************************************
// File:   adac.jj
// Author: Marcos Garralaga (795936), Victor Gallardo (801159)
// Date:   09/03/22
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//*****************************************************************

options {
   COMMON_TOKEN_ACTION = true;
//    DEBUG_PARSER = true;
}


PARSER_BEGIN(adac)
package traductor;


import java.lang.reflect.Field;
public class adac {
    public static void main(String[] args) {
    	adac parser;

    	try {
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac(System.in);
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			parser.S(); //invoca símbolo inicial de la gramática
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        }
        catch (ParseException e) {
        	System.err.println("SINT_ERROR: " + e.getMessage());
        } 
    }
}
PARSER_END(adac)
//------------ descripción del AL
SKIP :
{
    " "
| 	"\t"
| 	"\n"
| 	"\r"
|	<"--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

TOKEN_MGR_DECLS : {
  	static void CommonTokenAction(Token token) {
    	System.out.println("(" + token.beginLine + "," + token.beginColumn + "): " + getName(token) + " \"" + token.image + "\"");
  	}

	static String getName(Token token) {
		int constant = 0;
		for(Field f : adacConstants.class.getFields()){
			try {
				constant = f.getInt(null);
			}
			catch (Exception e) { return "ERROR"; }
			if (token.kind == constant) { return f.getName(); }
		}
		return "ERROR";
	}
}

TOKEN : //-------palabras reservadas e identificadores
{
 	< tBEGIN: "begin" >
 		{
 			//watchedToken.beginline;
			//watchedToken.begincolumn;
 		}
|	< tBOOL: "boolean" >
|	< tCHAR: "character" >
|	< tINT: "integer">
|	< tIF:   "if" >
|	< tELSE: "else">
|	< tWHILE: "while" >
|	< tPROCEDURE: "procedure" >
|	< tFUNCTION: "function" >
|	< tIS: "is" >
|	< tRETURN: "return" > 
|	< tDO: "do" >
|	< tEND: "end">
|	< tTHEN: "then">
}


TOKEN :  //-----caracteres , operadores y separadores
{
 	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< tNUM: (<DIGIT>)+ >
|	< tCAD: 
"\""													//Comillas
	(
			(~["\"","\\","\n","\r"])					//	Cualquier caracter que no sea \, ", \n, \r
       	
		|												//	o

			(											//	Algo escapado
				"\\"
				(
					["n","t","b","r","f","\\","'","\""]
				|
					["0"-"7"] ( ["0"-"7"] )?
				|
					["0"-"3"] ["0"-"7"] ["0"-"7"]
				)
			)
        |												//	o
			(											//	secuencia unicode escapada
				"\\u"
				["0"-"9","A"-"F","a"-"f"]
				["0"-"9","A"-"F","a"-"f"]
				["0"-"9","A"-"F","a"-"f"]
				["0"-"9","A"-"F","a"-"f"]
			)
    )*													//0 o mas veces
"\""													//Comillas
|
"\'"													//Comilla simple
	(
			(~["\'","\\","\n","\r"])					//	Cualquier caracter que no sea \, ", \n, \r
       	
		|												//	o

			(											//	Algo escapado
				"\\"
				(
					["n","t","b","r","f","\\","'","\""]
				|
					["0"-"7"] ( ["0"-"7"] )?
				|
					["0"-"3"] ["0"-"7"] ["0"-"7"]
				)
			)
        |												//	o
			(											//	secuencia unicode escapada
				"\\u"
				["0"-"9","A"-"F","a"-"f"]
				["0"-"9","A"-"F","a"-"f"]
				["0"-"9","A"-"F","a"-"f"]
				["0"-"9","A"-"F","a"-"f"]
			)
    )*													//0 o mas veces
"\'"													// Comilla simple
>
|	< tSUMA: "+" > 
|	< tRESTA: "-">
|	< tMUL:	"*" >
|	< tDIV: "div" >
|	< tMOD: "mod">
| 	< tCOMA: ",">
|	< tPCOMA: ";" >
|	< tMENOR: "<" >
|	< tMAYOR: ">" >
|	< tMENORI: "<=" >
|	< tMAYORI: ">=" >
|	< tIGUAL: "=" >
|	< tDISTINTO: "<>" >
|	< tASIGNACION: ":=">
|	< tPOPEN: "(" >
|	< tPCLOSE: ")" >
|	< tCOPEN: "[">
|	< tCCLOSE: "]">
|	< tOR: "or">
|	< tAND: "and" >
|	< tNOT: "not" >
|	< tFALSE: "false">
|	< tTRUE: "true" >
|	< tREF: "ref" >
|	< tVAL: "val" >
|	< tID: (<LETTER>)(("_")?(<LETTER>|<DIGIT>))*("_")? | ("_")((<LETTER>|<DIGIT>)("_")?)* >
}

SPECIAL_TOKEN:
{
	<ERROR:~[]> {
		System.out.println("ERROR LEXICO: (<" + matchedToken.beginLine + ", " + matchedToken.beginColumn
		+ ">): simbolo no reconocido: " + matchedToken.image ) ;
	}
}

//GENERAL

void S () : 
{

}
{
	(instruccion())+ < EOF >
}

void instruccion () :
{

}
{
	LOOKAHEAD(2)  inst_asig() <tPCOMA>
|	inst_declaracion_metodo()
|	inst_declaracion_variable() <tPCOMA>
|	inst_while()
| 	inst_seleccion() <tEND>
|	LOOKAHEAD(2)  inst_invocacion() <tPCOMA>
|	inst_return() <tPCOMA>
}

//DECLARACION VARIABLES

void inst_declaracion_variable() :
{

}
{
	tipos() <tID> (<tCOMA> <tID>)*
}

//DECLARACION METODO

void inst_declaracion_metodo() :
{
	
}
{
	(inst_declaracion_proc() | inst_declaracion_func())
}



void inst_return() :
{

}
{
	<tRETURN> expr()
}

void declaracion_variables() :
{
	
}
{
	((inst_declaracion_variable() <tPCOMA>) | inst_declaracion_metodo())*
}

//FUNCION
void inst_declaracion_func() :
{

}
{
	<tFUNCTION> tipos() <tID> (argumentos())? <tIS> declaracion_variables() <tBEGIN> (instruccion())* <tEND>
}
//PROCEDIMIENTO
void inst_declaracion_proc():
{

}
{
	<tPROCEDURE> <tID> (argumentos())? <tIS> declaracion_variables() <tBEGIN> (instruccion())* <tEND>
}

void inst_seleccion():
{

}
{
	<tIF> expr() <tTHEN> instruccion() masIf()
}

void masIf():
{

}
{
	(<tELSE> (instruccion())*)?	 // cadena vacía
}
// Regla relativa a los argumentos que se le pasa a una función
void argumentos() :
{

}
{
	<tPOPEN> (list_params())+ <tPCLOSE>
}

void list_params():
{

}
{
	parametro() (<tPCOMA> parametro())*
}

void parametro():
{

}
{
	<tREF> tipos() <tID> (<tCOMA> <tID>)*
|	<tVAL> tipos() <tID> (<tCOMA> <tID>)*
}


void tipos():
{

}
{
	<tINT>
| 	<tCHAR>
| 	<tBOOL>
}

void inst_invocacion() :
{

}
{
	<tID> <tPOPEN> (list_expr())? <tPCLOSE>
}

void list_expr() :
{

}
{
	expr() (<tCOMA> expr())*
}

//ASIGNACIONES

void inst_asig() :
{

}
{
	asignable() <tASIGNACION> expr()
}


void asignable() :
{

}
{
	LOOKAHEAD(2)  <tID> <tCOPEN> expr() <tCCLOSE>	// a[1]
|	LOOKAHEAD(2)  <tID>		// a


}

void expr() :
{

}
{
  	factor()  ( operador() factor() )*
}

void operador() :
{

}
{
	<tSUMA> | <tRESTA> | <tMUL> | <tDIV> | <tOR> | <tAND> | <tIGUAL> | <tMAYOR> | <tMAYORI> | <tMENOR> | <tMENORI> | <tDISTINTO> | <tMOD>
}

void factor() :
{

}
{
	<tNUM>		//3
|	<tCAD>		//"hola", 'test', "", ''
|	LOOKAHEAD(2)  <tID> <tCOPEN> expr() <tCCLOSE>	//a[expr]
|	LOOKAHEAD(2)  inst_invocacion()
|	LOOKAHEAD(2)  <tID>		//a
|	<tPOPEN> expr() <tPCLOSE>		//(expr)
|	<tNOT> factor()		//not expr
}

void inst_while() :
{

}
{
	<tWHILE> expr() <tDO> (instruccion())* <tEND>
}








/*	( 
		< tNUM > | < tID > | < tSUMA > | < tRESTA > | < tMUL > |<tELSE> | < tDIV > | < tPCOMA > | < tMENOR > | < tMAYOR > | < tMENORI > | < tMAYORI > | < tIGUAL > | < tDISTINTO > | < tASIGNACION > | < tPOPEN > | < tPCLOSE > | < tBEGIN > | < tBOOL > | < tCHAR > | < tINT > | < tIF > | < tWHILE > | < tPROCEDURE > | < tFUNCTION > | < tIS > | < tRETURN >| <tCAD> | <tDO> | <tEND> | < tTHEN > | <tCOMA> | <tCOPEN> | <tCCLOSE> | <tFALSE> | <tTRUE> | <tREF> | <tVAL> | <tOR> | <tAND>
	)+
	*/
	

