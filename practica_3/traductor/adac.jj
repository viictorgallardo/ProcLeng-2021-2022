//*****************************************************************
// File:   adac.jj
// Author: Marcos Garralaga (795936), Victor Gallardo (801159)
// Date:   09/03/22
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//*****************************************************************

options {
//    DEBUG_PARSER = true;
}


PARSER_BEGIN(adac)
package traductor;


import lib.errores.ErrorSemantico;
import lib.attributes.Attributes;
import lib.symbolTable.Symbol;
import lib.symbolTable.SymbolArray;
import lib.symbolTable.SymbolFunction;
import lib.symbolTable.SymbolProcedure;
import lib.symbolTable.SymbolBool;
import lib.symbolTable.SymbolChar;
import lib.symbolTable.SymbolInt;
import lib.symbolTable.SymbolString;
import lib.symbolTable.SymbolTable;
import lib.symbolTable.exceptions.IndexOOBException;
import lib.symbolTable.exceptions.AlreadyDefinedSymbolException;
import lib.symbolTable.exceptions.SymbolNotFoundException;
import lib.symbolTable.exceptions.TypeErrorException;
import lib.symbolTable.exceptions.IndexOOBException;

public class adac {
	public class Atributos {
		Symbol.Types tipo;
		String id;
		int dim;
	}
	static SymbolTable tabla = new SymbolTable();
	static ErrorSemantico errorSem = new ErrorSemantico();
    public static void main(String[] args) {
    	adac parser;

    	try {
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac(System.in);
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			parser.S(); //invoca símbolo inicial de la gramática
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        }
        catch (ParseException e) {
        	System.err.println("SINT_ERROR: " + e.getMessage());
        } 
    }
}
PARSER_END(adac)
//------------ descripción del AL
SKIP :
{
    " "
| 	"\t"
| 	"\n"
| 	"\r"
|	<"--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}



TOKEN : //-------palabras reservadas e identificadores
{
 	< tBEGIN: "begin" >
 		{
 			//watchedToken.beginline;
			//watchedToken.begincolumn;
 		}
|	< tBOOL: "boolean" >
|	< tCHAR: "character" >
|	< tINT: "integer">
|	< tIF:   "if" >
|	< tELSE: "else">
|	< tWHILE: "while" >
|	< tPROCEDURE: "procedure" >
|	< tFUNCTION: "function" >
|	< tIS: "is" >
|	< tRETURN: "return" > 
|	< tDO: "do" >
|	< tEND: "end" >
|	< tTHEN: "then" >
|	< tGET: "get" >
|	< tSKIPLINE: "skip_line" >
|	< tINT2CHAR: "int2char" >
|	< tCHAR2INT: "char2int" >
|	< tPUT : "put" >
|	< tPUTLINE: "put_line">
}


TOKEN :  //-----caracteres , operadores y separadores
{
 	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< tNUM: (<DIGIT>)+ >
|	< tCAD: "\"" (~["\t","\n","\r"])* "\"" >
|	< tCH: "\'" (~["\t","\n","\r"])? "\'" >
|	< tSUMA: "+" > 
|	< tRESTA: "-">
|	< tMUL:	"*" >
|	< tDIV: "div" >
|	< tMOD: "mod">
| 	< tCOMA: ",">
|	< tPCOMA: ";" >
|	< tMENOR: "<" >
|	< tMAYOR: ">" >
|	< tMENORI: "<=" >
|	< tMAYORI: ">=" >
|	< tIGUAL: "=" >
|	< tDISTINTO: "<>" >
|	< tASIGNACION: ":=">
|	< tPOPEN: "(" >
|	< tPCLOSE: ")" >
|	< tCOPEN: "[">
|	< tCCLOSE: "]">
|	< tOR: "or">
|	< tAND: "and" >
|	< tNOT: "not" >
|	< tFALSE: "false">
|	< tTRUE: "true" >
|	< tREF: "ref" >
|	< tVAL: "val" >
|	< tID: (<LETTER>)(("_")?(<LETTER>|<DIGIT>))*("_")? | ("_")((<LETTER>|<DIGIT>)("_")?)* >
}

SPECIAL_TOKEN:
{
	<ERROR:~[]> {
		System.out.println("ERROR LEXICO: (<" + matchedToken.beginLine + ", " + matchedToken.beginColumn
		+ ">): simbolo no reconocido: " + matchedToken.image ) ;
	}
}

//GENERAL

void S () : 
{

}
{
	(instruccion())+ < EOF >
}

void instruccion () :
{
	
}
{
	try {
		LOOKAHEAD(2)  inst_asig() <tPCOMA> 
	|	inst_get() <tPCOMA> 
	|	inst_skip_line() <tPCOMA> 
	|	inst_int2char() <tPCOMA> 
	|	inst_char2int() <tPCOMA> 
	|	inst_escribir() <tPCOMA>  
	| 	inst_escribir_linea() <tPCOMA> 
	|	inst_declaracion_metodo() 
	|	inst_declaracion_variable() <tPCOMA> 
	|	inst_while() 
	| 	inst_seleccion()  
	|	LOOKAHEAD(2)  inst_invocacion() <tPCOMA> 
	|	inst_return() <tPCOMA> 
	}
	catch(ParseException e) {
		System.out.println(e.toString());
		Token t;
		do {
		  t = getNextToken();
		}
		while (t.kind != tPCOMA);
	}
}

Attributes inst_int2char() :
{
	Attributes output;
}
{
	<tINT2CHAR> <tPOPEN> output=expr() <tPCLOSE>
	{
		//TODO: convertir output a char
		return output;
	}
}

Attributes inst_char2int() :
{
	Attributes output;
}
{
	<tCHAR2INT> <tPOPEN> output=expr() <tPCLOSE>
	{
		//TODO: convertir output a int
		return output;
	}
}

void inst_get() :
{

}
{
	<tGET> <tPOPEN> (list_asignables())+ <tPCLOSE>
}

void inst_skip_line() :
{

}
{
	<tSKIPLINE> <tCOPEN> <tCCLOSE>
}

//DECLARACION VARIABLES

void inst_declaracion_variable() :
{
	Symbol.Types tipo = Symbol.Types.UNDEFINED;

}
{
	tipo = tipos() variable(tipo) (<tCOMA> variable(tipo))* 
	{
		
	
		
	}
}

Symbol variable(Symbol.Types tipo) :
{
	Token nombre;
	Token dim = null;
}
{
	nombre = <tID> (<tCOPEN> dim = <tNUM> <tCCLOSE>)?
	{

	Symbol s;
	if(dim != null){
		s = new SymbolArray(nombre.image,Integer.parseInt(dim.image),tipo);
		s.constant = false;
		return s;
	}
	switch (tipo) {
		case INT:
			s = new SymbolInt(nombre.image);
			s.constant = false;
			try{
				tabla.insertSymbol(s);
			}
			catch(AlreadyDefinedSymbolException e){
				errorSem.deteccion(e,nombre);
			}
			return s;
		
		case BOOL:
			s = new SymbolBool(nombre.image);
			s.constant = false;
			try{
				tabla.insertSymbol(s);
			}
			catch(AlreadyDefinedSymbolException e){
				errorSem.deteccion(e,nombre);
			}
			return s;
		
		case CHAR:
			s = new SymbolChar(nombre.image);
			s.constant = false;
			try{
				tabla.insertSymbol(s);
			}
			catch(AlreadyDefinedSymbolException e){
				errorSem.deteccion(e,nombre);
			}
			return s;

		default:
			errorSem.deteccion(new TypeErrorException(), nombre, Symbol.Types.INT,Symbol.Types.CHAR,Symbol.Types.BOOL);
			return null;
			break;
	}
	

	
	}
}

//DECLARACION METODO

void inst_declaracion_metodo() :
{
	
}
{
	(inst_declaracion_proc() | inst_declaracion_func())
}



void inst_return() :
{

}
{
	<tRETURN> expr()
}

void declaracion_variables() :
{
	
}
{
	((inst_declaracion_variable() <tPCOMA>) | inst_declaracion_metodo())*
}

//FUNCION
void inst_declaracion_func() :
{
	Token nombre = null;
	Symbol.Types tipo = Symbol.Types.UNDEFINED;
}
{
	<tFUNCTION> tipo = tipos() nombre = <tID> (argumentos())?
	{
		try{
			SymbolProcedure s = new SymbolProcedure(nombre.image, null); //TODO numero de parametros
			s.constant = true;
			tabla.insertSymbol(s);
			tabla.insertBlock();
		}catch(AlreadyDefinedSymbolException e){
			errorSem.deteccion(e, nombre );
		}
	}
	<tIS> declaracion_variables() <tBEGIN> (instruccion())* <tEND>
	{
		tabla.removeBlock();
	}
}
//PROCEDIMIENTO
void inst_declaracion_proc():
{
	Token nombre = null;
}
{
	<tPROCEDURE> nombre = <tID> (argumentos())?
	{
		try{
			SymbolProcedure s = new SymbolProcedure(nombre.image, null); //TODO numero de parametros
			s.constant = true;
			tabla.insertSymbol(s);
			tabla.insertBlock();
		}catch(AlreadyDefinedSymbolException e){
			errorSem.deteccion(e, nombre );
		}
	}
	<tIS> declaracion_variables() <tBEGIN> (instruccion())* <tEND>
	{
		tabla.removeBlock();
	}
}


void inst_escribir():
{

}
{
	<tPUT> <tPOPEN> (list_expr())? <tPCLOSE>	
}

void inst_escribir_linea():
{

}
{
	<tPUTLINE> <tPOPEN> (list_expr())? <tPCLOSE>
}

void inst_seleccion():
{

}
{
	try {
		<tIF> expr() <tTHEN> (instruccion())* masIf() <tEND>
	}
	catch(ParseException e) {
		System.out.println(e.toString());
		Token t;
		do {
		  t = getNextToken();
		}
		while (t.kind != tEND);
	}
}

void masIf():
{

}
{
	(<tELSE> (instruccion())*)?	 // cadena vacía
}
// Regla relativa a los argumentos que se le pasa a una función
void argumentos() :
{

}
{
	<tPOPEN> (list_params())? <tPCLOSE>
}

void list_params():
{

}
{
	parametro() (<tPCOMA> parametro())*
}

void parametro():
{

}
{
	<tREF> tipos() <tID> (<tCOPEN> expr() <tCCLOSE>)? (<tCOMA> <tID> (<tCOPEN> expr() <tCCLOSE>)?)*
|	<tVAL> tipos() <tID> (<tCOPEN> expr() <tCCLOSE>)? (<tCOMA> <tID> (<tCOPEN> expr() <tCCLOSE>)?)*
}


Symbol.Types tipos():
{

}
{
	<tINT>
	{
	return Symbol.Types.INT;
	}
| 	<tCHAR>
	{
	return Symbol.Types.CHAR;
	}
| 	<tBOOL>
	{
	return Symbol.Types.BOOL;
	}
}

void inst_invocacion() :
{

}
{
	<tID> <tPOPEN> (list_expr())? <tPCLOSE>
}

void list_asignables() :
{

}
{
	asignable() (<tCOMA> asignable())*
}

void list_expr() :
{

}
{
	expr() (<tCOMA> expr())*
}

//ASIGNACIONES

void inst_asig() :
{
	Symbol asig = null;
	Attributes expr = null;
	Token temp;
}
{
	asig = asignable() temp=<tASIGNACION> expr = expr()
	{
		if (asig.type != expr.type){ // SE COMPRUEBA QUE EL ASIGNABLE Y LA EXPRESION A ASIGNAR SEAN DEL MISMO TIPO
			errorSem.deteccion(new TypeErrorException(), temp, asig.type);
		}
	}
}


// Si el asignable existe devuelve el asignable correspondiente de la tabla de simbolos, 
// si no devuelve null.
Symbol asignable() :
{
	Token nombre = null;
	Symbol output = null;
	Attributes expr = null;
}
{
	LOOKAHEAD(2)  nombre = <tID> <tCOPEN> expr = expr() <tCCLOSE>
	{
		try{ //TODO: QUE LA CONSTANTE CON LA QUE SE INDEXA EL VECTOR EXISTA
			//buscamos el simbolo asignable en la tabla de simbolos
			output = tabla.getSymbol(nombre.image);
			if(expr.type != Symbol.Types.INT){ // se mira si no se indexa con entero
				errorSem.deteccion(new TypeErrorException(), nombre, Symbol.Types.INT);
			}else{
			
				if(expr.valInt < ((SymbolArray)output).minInd || expr.valInt >= ((SymbolArray)output).maxInd){
					errorSem.deteccion(new IndexOOBException(),nombre, expr.valInt);
				}
			}	
		}catch(SymbolNotFoundException e){
			errorSem.deteccion(e,nombre);	
		}
		return output;
	}
|	LOOKAHEAD(2)  nombre = <tID>
	{
		try{ 
			//buscamos el simbolo asignable en la tabla de simbolos
			output = tabla.getSymbol(nombre.image);
		}catch(SymbolNotFoundException e){
			errorSem.deteccion(e,nombre);
		}
		return output;
	}	
}

Attributes expr() :
{
	Attributes output,f;
	Token op;
}
{
  	output=factor() (op=operador() f=factor()
	{
		System.out.println("Operacion "+op+"\n    "+output.toString()+"    "+f.toString());
		if(op.kind==tSUMA) {
			//Los dos tienen que ser enteros
			if (output.type!=Symbol.Types.INT || f.type!=Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT);
			}
			//Calculo
			output = new Attributes(output.valInt + f.valInt);
			return output;
		}
		else if(op.kind==tRESTA) {
			//Los dos tienen que ser enteros
			if (output.type!=Symbol.Types.INT || f.type!=Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT);
			}
			//Calculo
			output = new Attributes(output.valInt - f.valInt);
			return output;
		}
		else if(op.kind==tMUL) {
			//Los dos tienen que ser enteros
			if (output.type!=Symbol.Types.INT || f.type!=Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT);
			}
			//Calculo
			output = new Attributes(output.valInt * f.valInt);
			return output;
		}
		else if(op.kind==tDIV) {
			//Los dos tienen que ser enteros
			if (output.type!=Symbol.Types.INT || f.type!=Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT);
			}
			//Calculo
			output = new Attributes(output.valInt / f.valInt);
			return output;
		}
		else if(op.kind==tOR) {
			//Los dos tienen que ser booleanos
			if (output.type!=Symbol.Types.BOOL || f.type!=Symbol.Types.BOOL) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.BOOL);
			}
			//Calculo
			output = new Attributes(output.valBool || f.valBool);
			return output;
		}
		else if(op.kind==tAND) {
			//Los dos tienen que ser booleanos
			if (output.type!=Symbol.Types.BOOL || f.type!=Symbol.Types.BOOL) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.BOOL);
			}
			//Calculo
			output = new Attributes(output.valBool && f.valBool);
			return output;
		}
		else if(op.kind==tIGUAL) {
			//Los dos tienen que ser enteros o chars
			if ((output.type==Symbol.Types.INT && f.type==Symbol.Types.INT) || (output.type==Symbol.Types.CHAR && f.type==Symbol.Types.CHAR)) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (output.type==Symbol.Types.INT) { //Son los dos enteros
				output = new Attributes(output.valInt == f.valInt);
				return output;
			}
			else { //Son los dos chars
				output = new Attributes(output.valChar == f.valChar);
				return output;
			}
		}
		else if(op.kind==tMAYOR) {
			//Los dos tienen que ser enteros o chars
			if ((output.type==Symbol.Types.INT && f.type==Symbol.Types.INT) || (output.type==Symbol.Types.CHAR && f.type==Symbol.Types.CHAR)) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (output.type==Symbol.Types.INT) { //Son los dos enteros
				output = new Attributes(output.valInt > f.valInt);
				return output;
			}
			else { //Son los dos chars
				output = new Attributes(output.valChar > f.valChar);
				return output;
			}
		}
		else if(op.kind==tMAYORI) {
			//Los dos tienen que ser enteros o chars
			if ((output.type==Symbol.Types.INT && f.type==Symbol.Types.INT) || (output.type==Symbol.Types.CHAR && f.type==Symbol.Types.CHAR)) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (output.type==Symbol.Types.INT) { //Son los dos enteros
				output = new Attributes(output.valInt >= f.valInt);
				return output;
			}
			else { //Son los dos chars
				output = new Attributes(output.valChar >= f.valChar);
				return output;
			}
		}
		else if(op.kind==tMENOR) {
			//Los dos tienen que ser enteros o chars
			if ((output.type==Symbol.Types.INT && f.type==Symbol.Types.INT) || (output.type==Symbol.Types.CHAR && f.type==Symbol.Types.CHAR)) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (output.type==Symbol.Types.INT) { //Son los dos enteros
				output = new Attributes(output.valInt < f.valInt);
				return output;
			}
			else { //Son los dos chars
				output = new Attributes(output.valChar < f.valChar);
				return output;
			}
		}
		else if(op.kind==tMENORI) {
			//Los dos tienen que ser enteros o chars
			if ((output.type==Symbol.Types.INT && f.type==Symbol.Types.INT) || (output.type==Symbol.Types.CHAR && f.type==Symbol.Types.CHAR)) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (output.type==Symbol.Types.INT) { //Son los dos enteros
				output = new Attributes(output.valInt <= f.valInt);
				return output;
			}
			else { //Son los dos chars
				output = new Attributes(output.valChar <= f.valChar);
				return output;
			}
		}
		else if(op.kind==tDISTINTO) {
			//Los dos tienen que ser enteros o chars
			if ((output.type==Symbol.Types.INT && f.type==Symbol.Types.INT) || (output.type==Symbol.Types.CHAR && f.type==Symbol.Types.CHAR)) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (output.type==Symbol.Types.INT) { //Son los dos enteros
				output = new Attributes(output.valInt != f.valInt);
				return output;
			}
			else { //Son los dos chars
				output = new Attributes(output.valChar != f.valChar);
				return output;
			}
		}
		else if(op.kind==tMOD) {
			//Los dos tienen que ser enteros
			if (output.type!=Symbol.Types.INT || f.type!=Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT);
			}
			//Calculo
			output = new Attributes(output.valInt % f.valInt);
			return output;
		}
		else {
			//NOTE: Nunca deberia llegar aqui
			return output;
		}
	}
	)*

	{
		return output;
	}	
}

Token operador() :
{
	Token output;
}
{
	(output=<tSUMA> | output=<tRESTA> | output=<tMUL> | output=<tDIV> | output=<tOR> | output=<tAND> | output=<tIGUAL> | output=<tMAYOR> | output=<tMAYORI> | output=<tMENOR> | output=<tMENORI> | output=<tDISTINTO> | output=<tMOD>)
	{
		return output;
	}
}

Attributes factor() :
{
	Attributes output, data;
	Token t1;
}
{
	t1 = <tNUM>
	{
		output = new Attributes(Integer.parseInt(t1.image));
		System.out.println(output.toString());
		return output;
	}
|	t1 = <tCAD>
	{
		output = new Attributes(t1.image);
		System.out.println(output.toString());
		return output;
	}
	t1 = <tCH>
	{
		output = new Attributes(t1.image);
		System.out.println(output.toString());
		return output;
	}
|	(t1=<tTRUE> | t1=<tFALSE>)
	{
		output = new Attributes(Boolean.parseBoolean(t1.image));
		System.out.println(output.toString());
		return output;
	}
|	LOOKAHEAD(2)  t1=<tID> <tCOPEN> data=expr() <tCCLOSE>
	{
		//Acceder al vector
		try {
			Symbol v = tabla.getSymbol(t1.image);
			//Comprobar que el index es un int
			if (data.type != Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), t1, Symbol.Types.INT);
			}
			//Comprobar que el simbolo es un array
			if (v.getClass() != SymbolArray.class) {
				errorSem.deteccion(new TypeErrorException(), t1, Symbol.Types.ARRAY);
				output = new Attributes();
			}
			else {
				//Comprobar que el index es correcto
				if(data.isConstant) {	//Si sabemos el valor...
					if((data.valInt >= ((SymbolArray)v).maxInd) || (data.valInt < ((SymbolArray)v).minInd)) {
						errorSem.deteccion(new IndexOOBException(), t1, data.valInt);
					}
				}
				output = new Attributes(((SymbolArray)v).baseType,((SymbolArray)v).parClass);
			}
			System.out.println(output.toString());
			return output;
		}
		catch(SymbolNotFoundException e) {
			errorSem.deteccion(e, t1);
		}
	
	}
| 	output=inst_char2int()
	{
		System.out.println(output.toString());
		return output;
	}
|	output=inst_int2char()
	{
		System.out.println(output.toString());
		return output;
	}
|	LOOKAHEAD(2)  inst_invocacion()
	{
		//TODO
	}
|	<tID>
	{
		//TODO: Pillar de la tabla de simbolos, devolver ese
	}
|	<tPOPEN> output=expr() <tPCLOSE>
	{
		System.out.println(output.toString());
		return output;
	}
|	t1=<tNOT> output=factor()
	{
		if (output.type != Symbol.Types.BOOL) {
			errorSem.deteccion(new TypeErrorException(), t1, Symbol.Types.BOOL);
			return output;
		}
		output.valBool = !output.valBool;
		System.out.println(output.toString());
		return output;
	}
}

void inst_while() :
{

}
{
	try {
		<tWHILE> expr() <tDO> (instruccion())* <tEND>
	}
	catch(ParseException e) {
		System.out.println(e.toString());
		Token t;
		do {
		  t = getNextToken();
		}
		while (t.kind != tEND);
	}
}
	

