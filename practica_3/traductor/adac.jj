//*****************************************************************
// File:   adac.jj
// Author: Marcos Garralaga (795936), Victor Gallardo (801159)
// Date:   09/03/22
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//*****************************************************************

options {
//    DEBUG_PARSER = true;
}


PARSER_BEGIN(adac)
package traductor;


import lib.*;
public class Atributos {
	Symbol.Types tipo;
	String id;
	int dim;
}
public class Valor {
	Symbol.Types tipo;
	int dim;
	boolean v_bool;
	int v_int;
	char v_char;
	String v_string;
	boolean isConst;
	boolean isAsig;
}
public class adac {
	static SymbolTable tabla = new symbolTable();
	ErrorSemantico errorSem = new ErrorSemantico
    public static void main(String[] args) {
    	adac parser;

    	try {
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac(System.in);
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			parser.S(); //invoca símbolo inicial de la gramática
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        }
        catch (ParseException e) {
        	System.err.println("SINT_ERROR: " + e.getMessage());
        } 
    }
}
PARSER_END(adac)
//------------ descripción del AL
SKIP :
{
    " "
| 	"\t"
| 	"\n"
| 	"\r"
|	<"--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}



TOKEN : //-------palabras reservadas e identificadores
{
 	< tBEGIN: "begin" >
 		{
 			//watchedToken.beginline;
			//watchedToken.begincolumn;
 		}
|	< tBOOL: "boolean" >
|	< tCHAR: "character" >
|	< tINT: "integer">
|	< tIF:   "if" >
|	< tELSE: "else">
|	< tWHILE: "while" >
|	< tPROCEDURE: "procedure" >
|	< tFUNCTION: "function" >
|	< tIS: "is" >
|	< tRETURN: "return" > 
|	< tDO: "do" >
|	< tEND: "end" >
|	< tTHEN: "then" >
|	< tGET: "get" >
|	< tSKIPLINE: "skip_line" >
|	< tINT2CHAR: "int2char" >
|	< tCHAR2INT: "char2int" >
|	< tPUT : "put" >
|	< tPUTLINE: "put_line">
}


TOKEN :  //-----caracteres , operadores y separadores
{
 	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< tNUM: (<DIGIT>)+ >
|	< tCAD: "\"" (~["\t","\n","\r"])* "\"" >
|	< tCHAR: "\'" (~["\t","\n","\r"])? "\'" >
|	< tSUMA: "+" > 
|	< tRESTA: "-">
|	< tMUL:	"*" >
|	< tDIV: "div" >
|	< tMOD: "mod">
| 	< tCOMA: ",">
|	< tPCOMA: ";" >
|	< tMENOR: "<" >
|	< tMAYOR: ">" >
|	< tMENORI: "<=" >
|	< tMAYORI: ">=" >
|	< tIGUAL: "=" >
|	< tDISTINTO: "<>" >
|	< tASIGNACION: ":=">
|	< tPOPEN: "(" >
|	< tPCLOSE: ")" >
|	< tCOPEN: "[">
|	< tCCLOSE: "]">
|	< tOR: "or">
|	< tAND: "and" >
|	< tNOT: "not" >
|	< tFALSE: "false">
|	< tTRUE: "true" >
|	< tREF: "ref" >
|	< tVAL: "val" >
|	< tID: (<LETTER>)(("_")?(<LETTER>|<DIGIT>))*("_")? | ("_")((<LETTER>|<DIGIT>)("_")?)* >
}

SPECIAL_TOKEN:
{
	<ERROR:~[]> {
		System.out.println("ERROR LEXICO: (<" + matchedToken.beginLine + ", " + matchedToken.beginColumn
		+ ">): simbolo no reconocido: " + matchedToken.image ) ;
	}
}

//GENERAL

void S () : 
{

}
{
	(instruccion())+ < EOF >
}

void instruccion () :
{

}
{
	try {
		LOOKAHEAD(2)  inst_asig() <tPCOMA>
	|	inst_get() <tPCOMA>
	|	inst_skip_line() <tPCOMA>
	|	inst_int2char() <tPCOMA>
	|	inst_char2int() <tPCOMA>
	|	inst_escribir() <tPCOMA> 
	| 	inst_escribir_linea() <tPCOMA>
	|	inst_declaracion_metodo()
	|	inst_declaracion_variable() <tPCOMA>
	|	inst_while()
	| 	inst_seleccion() 
	|	LOOKAHEAD(2)  inst_invocacion() <tPCOMA>
	|	inst_return() <tPCOMA>
	}
	catch(ParseException e) {
		System.out.println(e.toString());
		Token t;
		do {
		  t = getNextToken();
		}
		while (t.kind != tPCOMA);
	}
}

void inst_int2char() :
{

}
{
	<tINT2CHAR> <tPOPEN> expr() <tPCLOSE>
}

void inst_char2int() :
{

}
{
	<tCHAR2INT> <tPOPEN> expr() <tPCLOSE>
}

void inst_get() :
{

}
{
	<tGET> <tPOPEN> (list_asignables())+ <tPCLOSE>
}

void inst_skip_line() :
{

}
{
	<tSKIPLINE> <tCOPEN> <tCCLOSE>
}

//DECLARACION VARIABLES

void inst_declaracion_variable() :
{
	Symbol.Types tipo = Symbol.Types.UNDEFINED;
	Atributos variable_atr = new Atributos();
}
{
	tipo = tipos() variable_atr = variable(tipo) (<tCOMA> variable(tipo))* 
	{
		System.out.println(test);
		if ( tipo == 1 ){		//INT
			SymbolInt s = new SymbolInt(variable_atr.id);
		}else if( tipo == 2){
			SymbolBool s = new SymbolBool(variable_atr.id);
		}
		else if( tipo == 3){
			SymbolChar s = new SymbolChar(variable_atr.id);
		}
		s.constant = false;
		try{
			tabla.insert(s);
		}
		catch(AlreadyDefinedSymbolException e){
			System.err.println("Error: " + variable_atr.id + "ya esta declarado");
		}
		
	}
}

Atributos variable(SymbolType tipo) :
{
	Token nombre;
	Token dim;
	Atributos caracteristicas = new Atributos();
	Valor expr_devuelta = new Valor();
}
{
	nombre = <tID> (<tCOPEN> expr_devuelta = expr() <tCCLOSE>)?
	caracteristicas.id = nombre.image;
	caracteristicas.tipo = tipo;
	caracteristicas.dim = expr_devuelta.dim;
}

//DECLARACION METODO

void inst_declaracion_metodo() :
{
	
}
{
	(inst_declaracion_proc() | inst_declaracion_func())
}



void inst_return() :
{

}
{
	<tRETURN> expr()
}

void declaracion_variables() :
{
	
}
{
	((inst_declaracion_variable() <tPCOMA>) | inst_declaracion_metodo())*
}

//FUNCION
void inst_declaracion_func() :
{

}
{
	<tFUNCTION> tipos() <tID> (argumentos())? <tIS> declaracion_variables() <tBEGIN> (instruccion())* <tEND>
}
//PROCEDIMIENTO
void inst_declaracion_proc():
{

}
{
	<tPROCEDURE> <tID> (argumentos())? <tIS> declaracion_variables() <tBEGIN> (instruccion())* <tEND>
}


void inst_escribir():
{

}
{
	<tPUT> <tPOPEN> (list_expr())? <tPCLOSE>	
}

void inst_escribir_linea():
{

}
{
	<tPUTLINE> <tPOPEN> (list_expr())? <tPCLOSE>
}

void inst_seleccion():
{

}
{
	try {
		<tIF> expr() <tTHEN> (instruccion())* masIf() <tEND>
	}
	catch(ParseException e) {
		System.out.println(e.toString());
		Token t;
		do {
		  t = getNextToken();
		}
		while (t.kind != tEND);
	}
}

void masIf():
{

}
{
	(<tELSE> (instruccion())*)?	 // cadena vacía
}
// Regla relativa a los argumentos que se le pasa a una función
void argumentos() :
{

}
{
	<tPOPEN> (list_params())? <tPCLOSE>
}

void list_params():
{

}
{
	parametro() (<tPCOMA> parametro())*
}

void parametro():
{

}
{
	<tREF> tipos() <tID> (<tCOPEN> expr() <tCCLOSE>)? (<tCOMA> <tID> (<tCOPEN> expr() <tCCLOSE>)?)*
|	<tVAL> tipos() <tID> (<tCOPEN> expr() <tCCLOSE>)? (<tCOMA> <tID> (<tCOPEN> expr() <tCCLOSE>)?)*
}


Symbol.Types tipos():
{

}
{
	<tINT>
	{
		return Symbol.Types.INT;
	}
| 	<tCHAR>
{
	return Symbol.Types.CHAR;
}
| 	<tBOOL>
{
	return Symbol.Types.BOOL;
}
}

void inst_invocacion() :
{

}
{
	<tID> <tPOPEN> (list_expr())? <tPCLOSE>
}

void list_asignables() :
{

}
{
	asignable() (<tCOMA> asignable())*
}

void list_expr() :
{

}
{
	expr() (<tCOMA> expr())*
}

//ASIGNACIONES

void inst_asig() :
{

}
{
	asignable() <tASIGNACION> expr()
}


void asignable() :
{

}
{
	LOOKAHEAD(2)  <tID> <tCOPEN> expr() <tCCLOSE>
|	LOOKAHEAD(2)  <tID>	
}

Valor expr() :
{
	Valor output;
}
{
  	factor()  ( operador() factor() )*
}

void operador() :
{

}
{
	<tSUMA> | <tRESTA> | <tMUL> | <tDIV> | <tOR> | <tAND> | <tIGUAL> | <tMAYOR> | <tMAYORI> | <tMENOR> | <tMENORI> | <tDISTINTO> | <tMOD>
}

Valor factor() :
{
	Valor output, data;
	Token t1;
}
{
	t1 = <tNUM>
	{
		output.tipo = Symbol.Types.INT;
		output.isConst = true;
		output.v_int = Integer.parseInt(t1.image);
	}
|	t1 = <tCAD>
	{
		output.tipo = Symbol.Types.STRING;
		output.isConst = true;
		output.v_string = t1.image;
	}
	t1 = <tCHAR>
	{
		output.tipo = Symbol.Types.CHAR; 
		output.isConst = true;
		output.v_char = t1.image;
	}
|	t1 = (<tTRUE> | <tFALSE>)
	{
		output.tipo = Symbol.Types.BOOL;
		output.isConst = true;
		output.v_int = Boolean.parseBoolean(t1.image);
	}
|	LOOKAHEAD(2)  t1=<tID> <tCOPEN> data=expr() <tCCLOSE>
	{
		output.isAsig = true;
		Symbol var = null;
		try {
			var = tabla.getSymbol(t1.image)
			output.tipo = var.type;
		}
		catch {
			errorSem.deteccion(new SymbolNotFoundException(),t1)
		}
		if (output.tipo != data.tipo) { //Lanzar excepcion expr no tiene el tipo correcto}
	}
| 	inst_char2int()
|	inst_int2char()
|	LOOKAHEAD(2)  inst_invocacion()
|	<tID>		//a
|	<tPOPEN> expr() <tPCLOSE>		//(expr)
|	<tNOT> factor()		//not expr
}

void inst_while() :
{

}
{
	try {
		<tWHILE> expr() <tDO> (instruccion())* <tEND>
	}
	catch(ParseException e) {
		System.out.println(e.toString());
		Token t;
		do {
		  t = getNextToken();
		}
		while (t.kind != tEND);
	}
}








/*	( 
		< tNUM > | < tID > | < tSUMA > | < tRESTA > | < tMUL > |<tELSE> | < tDIV > | < tPCOMA > | < tMENOR > | < tMAYOR > | < tMENORI > | < tMAYORI > | < tIGUAL > | < tDISTINTO > | < tASIGNACION > | < tPOPEN > | < tPCLOSE > | < tBEGIN > | < tBOOL > | < tCHAR > | < tINT > | < tIF > | < tWHILE > | < tPROCEDURE > | < tFUNCTION > | < tIS > | < tRETURN >| <tCAD> | <tDO> | <tEND> | < tTHEN > | <tCOMA> | <tCOPEN> | <tCCLOSE> | <tFALSE> | <tTRUE> | <tREF> | <tVAL> | <tOR> | <tAND>
	)+
	*/
	

