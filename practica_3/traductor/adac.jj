//*****************************************************************
// File:   adac.jj
// Author: Marcos Garralaga (795936), Victor Gallardo (801159)
// Date:   09/03/22
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//*****************************************************************

options {
  //DEBUG_PARSER = true;
}


PARSER_BEGIN(adac)
package traductor;


import lib.errores.ErrorSemantico;
import lib.attributes.Attributes;
import lib.symbolTable.Symbol;
import lib.symbolTable.SymbolArray;
import lib.symbolTable.SymbolFunction;
import lib.symbolTable.SymbolProcedure;
import lib.symbolTable.SymbolBool;
import lib.symbolTable.SymbolChar;
import lib.symbolTable.SymbolInt;
import lib.symbolTable.SymbolString;
import lib.symbolTable.SymbolTable;
import lib.symbolTable.exceptions.IndexOOBException;
import lib.symbolTable.exceptions.AlreadyDefinedSymbolException;
import lib.symbolTable.exceptions.SymbolNotFoundException;
import lib.symbolTable.exceptions.TypeErrorException;
import lib.symbolTable.exceptions.IndexOOBException;

public class adac {
	static SymbolTable tabla = new SymbolTable();
	static ErrorSemantico errorSem = new ErrorSemantico();
    public static void main(String[] args) {
    	adac parser;

    	try {
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac(System.in);
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			parser.S(); //invoca símbolo inicial de la gramática
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        }
        catch (ParseException e) {
        	System.err.println("SINT_ERROR: " + e.getMessage());
        } 
    }
}
PARSER_END(adac)
//------------ descripción del AL
SKIP :
{
    " "
| 	"\t"
| 	"\n"
| 	"\r"
|	<"--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}



TOKEN : //-------palabras reservadas e identificadores
{
 	< tBEGIN: "begin" >
 		{
 			//watchedToken.beginline;
			//watchedToken.begincolumn;
 		}
|	< tBOOL: "boolean" >
|	< tCHAR: "character" >
|	< tINT: "integer">
|	< tIF:   "if" >
|	< tELSE: "else">
|	< tWHILE: "while" >
|	< tPROCEDURE: "procedure" >
|	< tFUNCTION: "function" >
|	< tIS: "is" >
|	< tRETURN: "return" > 
|	< tDO: "do" >
|	< tEND: "end" >
|	< tTHEN: "then" >
|	< tGET: "get" >
|	< tSKIPLINE: "skip_line" >
|	< tINT2CHAR: "int2char" >
|	< tCHAR2INT: "char2int" >
|	< tPUT : "put" >
|	< tPUTLINE: "put_line">
}


TOKEN :  //-----caracteres , operadores y separadores
{
 	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< tNUM: (<DIGIT>)+ >
|	< tCAD: "\"" (~["\t","\n","\r"])* "\"" >
|	< tCH: "\'" (~["\t","\n","\r"])? "\'" >
|	< tSUMA: "+" > 
|	< tRESTA: "-">
|	< tMUL:	"*" >
|	< tDIV: "div" >
|	< tMOD: "mod">
| 	< tCOMA: ",">
|	< tPCOMA: ";" >
|	< tMENOR: "<" >
|	< tMAYOR: ">" >
|	< tMENORI: "<=" >
|	< tMAYORI: ">=" >
|	< tIGUAL: "=" >
|	< tDISTINTO: "<>" >
|	< tASIGNACION: ":=">
|	< tPOPEN: "(" >
|	< tPCLOSE: ")" >
|	< tCOPEN: "[">
|	< tCCLOSE: "]">
|	< tOR: "or">
|	< tAND: "and" >
|	< tNOT: "not" >
|	< tFALSE: "false">
|	< tTRUE: "true" >
|	< tREF: "ref" >
|	< tVAL: "val" >
|	< tID: (<LETTER>)(("_")?(<LETTER>|<DIGIT>))*("_")? | ("_")((<LETTER>|<DIGIT>)("_")?)* >
}

SPECIAL_TOKEN:
{
	<ERROR:~[]> {
		System.out.println("ERROR LEXICO: (<" + matchedToken.beginLine + ", " + matchedToken.beginColumn
		+ ">): simbolo no reconocido: " + matchedToken.image ) ;
	}
}

//GENERAL

void S () : 
{

}
{
	(instruccion())+ < EOF >
}

void instruccion () :
{
	
}
{
	try {
		LOOKAHEAD(2)  inst_asig() <tPCOMA> 
	|	inst_get() <tPCOMA> 
	|	inst_skip_line() <tPCOMA> 
	|	inst_int2char() <tPCOMA> 
	|	inst_char2int() <tPCOMA> 
	|	inst_escribir() <tPCOMA>  
	| 	inst_escribir_linea() <tPCOMA> 
	|	inst_declaracion_metodo() 
	|	inst_declaracion_variable() <tPCOMA> 
	|	inst_while() 
	| 	inst_seleccion()  
	|	LOOKAHEAD(2)  inst_invocacion() <tPCOMA> 
	|	inst_return() <tPCOMA> 
	}
	catch(ParseException e) {
		System.out.println(e.toString());
		Token t;
		do {
		  t = getNextToken();
		}
		while (t.kind != tPCOMA);
	}
}

Attributes inst_int2char() :
{
	Attributes output;
	Attributes a = new Attributes();
	Token temp;
}
{
	<tINT2CHAR> temp=<tPOPEN> output=expr(a) <tPCLOSE>
	{
		if(output.type != Symbol.Types.INT) {
			errorSem.deteccion(new TypeErrorException(),temp,Symbol.Types.INT);
		}
		return new Attributes((char)(output.valInt));
	}
}

Attributes inst_char2int() :
{
	Attributes output;
	Attributes a = new Attributes();
	Token temp;
}
{
	<tCHAR2INT> temp=<tPOPEN> output=expr(a) <tPCLOSE>
	{
		if(output.type != Symbol.Types.CHAR) {
			errorSem.deteccion(new TypeErrorException(),temp,Symbol.Types.CHAR);
		}
		return new Attributes(Character.getNumericValue(output.valChar));
	}
}

void inst_get() :
{

}
{
	<tGET> <tPOPEN> (list_asignables())+ <tPCLOSE>
}

void inst_skip_line() :
{

}
{
	<tSKIPLINE> <tCOPEN> <tCCLOSE>
}

//DECLARACION VARIABLES

void inst_declaracion_variable() :
{
	Symbol.Types tipo = Symbol.Types.UNDEFINED;

}
{
	tipo = tipos() variable(tipo) (<tCOMA> variable(tipo))* 
	{
		
		
		
	}
}

Symbol variable(Symbol.Types tipo) :
{
	Token nombre;
	Token dim = null;
}
{
	nombre = <tID> (<tCOPEN> dim = <tNUM> <tCCLOSE>)?
	{

		System.out.println("Declaramos variable");
		System.out.println(tabla.toString());
		System.out.println("Fin declaracion");

	Symbol s;
	if(dim != null){
		s = new SymbolArray(nombre.image,Integer.parseInt(dim.image),tipo);
		s.constant = false;
		try{
			tabla.insertSymbol(s);
		}
		catch(AlreadyDefinedSymbolException e){
			errorSem.deteccion(e,nombre);
		}
		return s;
	}
	switch (tipo) {
		case INT:
			s = new SymbolInt(nombre.image);
			s.constant = false;
			try{
				tabla.insertSymbol(s);
			}
			catch(AlreadyDefinedSymbolException e){
				errorSem.deteccion(e,nombre);
			}
			return s;
		
		case BOOL:
			s = new SymbolBool(nombre.image);
			s.constant = false;
			try{
				tabla.insertSymbol(s);
			}
			catch(AlreadyDefinedSymbolException e){
				errorSem.deteccion(e,nombre);
			}
			return s;
		
		case CHAR:
			s = new SymbolChar(nombre.image);
			s.constant = false;
			try{
				tabla.insertSymbol(s);
			}
			catch(AlreadyDefinedSymbolException e){
				errorSem.deteccion(e,nombre);
			}
			return s;
		default:
			errorSem.deteccion(new TypeErrorException(), nombre, Symbol.Types.INT,Symbol.Types.CHAR,Symbol.Types.BOOL);
			return null;
			break;
		}
		
		
	
	}
}

//DECLARACION METODO

void inst_declaracion_metodo() :
{
	
}
{
	(inst_declaracion_proc() | inst_declaracion_func())
}



void inst_return() :
{
	Attributes a = new Attributes();
}
{
	<tRETURN> expr(a)
}

void declaracion_variables() :
{
	
}
{
	((inst_declaracion_variable() <tPCOMA>) | inst_declaracion_metodo())*
}

//FUNCION
void inst_declaracion_func() :
{
	Token nombre = null;
	Symbol.Types tipo = Symbol.Types.UNDEFINED;
}
{
	<tFUNCTION> tipo = tipos() nombre = <tID> (argumentos())?
	{
		try{
			SymbolProcedure s = new SymbolFunction(nombre.image, null); //TODO numero de parametros
			s.constant = true;
			tabla.insertSymbol(s);
			tabla.insertBlock();
		}catch(AlreadyDefinedSymbolException e){
			errorSem.deteccion(e, nombre );
		}
	}
	<tIS> declaracion_variables() <tBEGIN> (instruccion())* <tEND>
	{
		tabla.removeBlock();
	}
}
//PROCEDIMIENTO
void inst_declaracion_proc():
{
	Token nombre = null;
}
{
	<tPROCEDURE> nombre = <tID> (argumentos())?
	{
		try{
			SymbolProcedure s = new SymbolProcedure(nombre.image, null); //TODO numero de parametros
			s.constant = true;
			tabla.insertSymbol(s);
			tabla.insertBlock();
		}catch(AlreadyDefinedSymbolException e){
			errorSem.deteccion(e, nombre );
		}
	}
	<tIS> declaracion_variables() <tBEGIN> (instruccion())* <tEND>
	{
		tabla.removeBlock();
	}
}


void inst_escribir():
{

}
{
	<tPUT> <tPOPEN> (list_expr())? <tPCLOSE>	
}

void inst_escribir_linea():
{

}
{
	<tPUTLINE> <tPOPEN> (list_expr())? <tPCLOSE>
}

void inst_seleccion():
{
	Attributes a = new Attributes();
}
{
	try {
		<tIF> expr(a) <tTHEN> (instruccion())* masIf() <tEND>
	}
	catch(ParseException e) {
		System.out.println(e.toString());
		Token t;
		do {
		  t = getNextToken();
		}
		while (t.kind != tEND);
	}
}

void masIf():
{

}
{
	(<tELSE> (instruccion())*)?	 // cadena vacía
}
// Regla relativa a los argumentos que se le pasa a una función
void argumentos() :
{

}
{
	<tPOPEN> (list_params())? <tPCLOSE>
}

void list_params():
{

}
{
	parametro() (<tPCOMA> parametro())*
}

void parametro():
{
	
}
{
	ref = <tREF> tipo = tipos() name = <tID> (<tCOPEN> dim = expr(a) <tCCLOSE>)? masParametros();
	{

	}

|	<tVAL> tipos() <tID> (<tCOPEN> expr(a) <tCCLOSE>)? masParametros();
}


void masParametros() :
{

}
{
	(<tCOMA> <tID> (<tCOPEN> expr(a) <tCCLOSE>)?)*
}


Symbol.Types tipos():
{

}
{
	<tINT>
	{
	return Symbol.Types.INT;
	}
| 	<tCHAR>
	{
	return Symbol.Types.CHAR;
	}
| 	<tBOOL>
	{
	return Symbol.Types.BOOL;
	}
}

void inst_invocacion() :
{

}
{
	<tID> <tPOPEN> (list_expr())? <tPCLOSE>
}

void list_asignables() :
{

}
{
	asignable() (<tCOMA> asignable())*
}

void list_expr() :
{
	Attributes a = new Attributes();
}
{
	expr(a) (<tCOMA> expr(a))*
}

//ASIGNACIONES

void inst_asig() :
{
	Symbol asig = null;
	Attributes expr = null;
	Attributes a = new Attributes();
	Token temp;
}
{
	asig = asignable() temp=<tASIGNACION> expr = expr(a)
	{
		if(asig.constant){
			System.err.println("Error: " + asig.name + "es una cte. usada como variable");
		}
		else{
			if ((asig.type != expr.type) && (asig.type != Symbol.Types.ARRAY)){ // SE COMPRUEBA QUE EL ASIGNABLE Y LA EXPRESION A ASIGNAR SEAN DEL MISMO TIPO
				System.out.println("El tipo de asignable es " + asig.type);
				System.out.println("El tipo de la expr es " + expr.type);
				errorSem.deteccion(new TypeErrorException(), temp, asig.type);
			}
			else{
				if(asig.type == Symbol.Types.ARRAY){

				}
				else if(asig.type == Symbol.Types.INT){
					SymbolInt s = (SymbolInt)asig;
					s.value = expr.valInt;
				}
				else if(asig.type == Symbol.Types.CHAR){
					SymbolChar s = (SymbolChar)asig;
					s.value = expr.valChar;
				}
				else if(asig.type == Symbol.Types.BOOL){
					SymbolBool s = (SymbolBool)asig;
					s.value = expr.valBool;
				}
			}
		}
		System.out.println("Estamos en asig");
		System.out.println(tabla.toString());
		System.out.println("Fin asig");
	}
}


// Si el asignable existe devuelve el asignable correspondiente de la tabla de simbolos, 
// si no devuelve null.
Symbol asignable() :
{
	Token nombre = null;
	Symbol output = null;
	Attributes expr = null;
	Attributes a = new Attributes();
}
{
	LOOKAHEAD(2)  nombre = <tID> <tCOPEN> expr = expr(a) <tCCLOSE>
	{
		try{
			//buscamos el simbolo asignable en la tabla de simbolos
			output = tabla.getSymbol(nombre.image);
			// Se mira si el vector es de tipo array
			if(output.type != Symbol.Types.ARRAY) {
				errorSem.deteccion(new TypeErrorException(), nombre, Symbol.Types.ARRAY);
			}
			if(expr.type != Symbol.Types.INT){ // se mira si no se indexa con entero
				errorSem.deteccion(new TypeErrorException(), nombre, Symbol.Types.INT);
			}
			else{
				if(expr.valInt < ((SymbolArray)output).minInd || expr.valInt >= ((SymbolArray)output).maxInd){
					errorSem.deteccion(new IndexOOBException(),nombre, expr.valInt);
				}
			}	
		}catch(SymbolNotFoundException e){
			errorSem.deteccion(e,nombre);	
		}
		return output;
	}
|	LOOKAHEAD(2)  nombre = <tID>
	{
		try{ 
			//buscamos el simbolo asignable en la tabla de simbolos
			output = tabla.getSymbol(nombre.image);
		}catch(SymbolNotFoundException e){
			errorSem.deteccion(e,nombre);
		}
		return output;
	}	
}

Attributes expr(Attributes prev) :
{
	Attributes a = new Attributes();
	Attributes a1,a2;
}
{
  	a1=factor() a2=expr_plus(a1)
	{
		return a2;
	}
}

Attributes expr_plus(Attributes prev) :
{
	Attributes a1, a2;
	Attributes mid = new Attributes();
	Token op;
}
{
	op=operador() a1=factor()
	{
		System.out.println("Operacion "+op+"\n    "+prev.toString()+"    "+a1.toString());
		if(op.kind==tSUMA) {
			//Los dos tienen que ser enteros
			if (prev.type!=Symbol.Types.INT || a1.type!=Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT);
			}
			//Calculo
			mid = new Attributes(prev.valInt + a1.valInt);
		}
		else if(op.kind==tRESTA) {
			//Los dos tienen que ser enteros
			if (prev.type!=Symbol.Types.INT || a1.type!=Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT);
			}
			//Calculo
			mid = new Attributes(prev.valInt - a1.valInt);
		}
		else if(op.kind==tMUL) {
			//Los dos tienen que ser enteros
			if (prev.type!=Symbol.Types.INT || a1.type!=Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT);
			}
			//Calculo
			mid = new Attributes(prev.valInt * a1.valInt);
		}
		else if(op.kind==tDIV) {
			//Los dos tienen que ser enteros
			if (prev.type!=Symbol.Types.INT || a1.type!=Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT);
			}
			//Calculo
			mid = new Attributes(prev.valInt / a1.valInt);
		}
		else if(op.kind==tOR) {
			//Los dos tienen que ser booleanos
			if (prev.type!=Symbol.Types.BOOL || a1.type!=Symbol.Types.BOOL) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.BOOL);
			}
			//Calculo
			mid = new Attributes(prev.valBool || a1.valBool);
		}
		else if(op.kind==tAND) {
			//Los dos tienen que ser booleanos
			if (prev.type!=Symbol.Types.BOOL || a1.type!=Symbol.Types.BOOL) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.BOOL);
			}
			//Calculo
			mid = new Attributes(prev.valBool && a1.valBool);
		}
		else if(op.kind==tIGUAL) {
			//Los dos tienen que ser enteros o chars
			if ((prev.type==Symbol.Types.INT && a1.type==Symbol.Types.INT) || (prev.type==Symbol.Types.CHAR && a1.type==Symbol.Types.CHAR)) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (prev.type==Symbol.Types.INT) { //Son los dos enteros
				mid = new Attributes(prev.valInt == a1.valInt);
			}
			else { //Son los dos chars
				mid = new Attributes(prev.valChar == a1.valChar);
			}
		}
		else if(op.kind==tMAYOR) {
			//Los dos tienen que ser enteros o chars
			if ((prev.type==Symbol.Types.INT && a1.type==Symbol.Types.INT) || (prev.type==Symbol.Types.CHAR && a1.type==Symbol.Types.CHAR)) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (prev.type==Symbol.Types.INT) { //Son los dos enteros
				mid = new Attributes(prev.valInt > a1.valInt);
			}
			else { //Son los dos chars
				mid = new Attributes(prev.valChar > a1.valChar);
			}
		}
		else if(op.kind==tMAYORI) {
			//Los dos tienen que ser enteros o chars
			if ((prev.type==Symbol.Types.INT && a1.type==Symbol.Types.INT) || (prev.type==Symbol.Types.CHAR && a1.type==Symbol.Types.CHAR)) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (prev.type==Symbol.Types.INT) { //Son los dos enteros
				mid = new Attributes(prev.valInt >= a1.valInt);
			}
			else { //Son los dos chars
				mid = new Attributes(prev.valChar >= a1.valChar);
			}
		}
		else if(op.kind==tMENOR) {
			//Los dos tienen que ser enteros o chars
			if ((prev.type==Symbol.Types.INT && a1.type==Symbol.Types.INT) || (prev.type==Symbol.Types.CHAR && a1.type==Symbol.Types.CHAR)) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (prev.type==Symbol.Types.INT) { //Son los dos enteros
				mid = new Attributes(prev.valInt < a1.valInt);
			}
			else { //Son los dos chars
				mid = new Attributes(prev.valChar < a1.valChar);
			}
		}
		else if(op.kind==tMENORI) {
			//Los dos tienen que ser enteros o chars
			if ((prev.type==Symbol.Types.INT && a1.type==Symbol.Types.INT) || (prev.type==Symbol.Types.CHAR && a1.type==Symbol.Types.CHAR)) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (prev.type==Symbol.Types.INT) { //Son los dos enteros
				mid = new Attributes(prev.valInt <= a1.valInt);
			}
			else { //Son los dos chars
				mid = new Attributes(prev.valChar <= a1.valChar);
			}
		}
		else if(op.kind==tDISTINTO) {
			//Los dos tienen que ser enteros o chars
			if ((prev.type==Symbol.Types.INT && a1.type==Symbol.Types.INT) || (prev.type==Symbol.Types.CHAR && a1.type==Symbol.Types.CHAR)) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (prev.type==Symbol.Types.INT) { //Son los dos enteros
				mid = new Attributes(prev.valInt != a1.valInt);
			}
			else { //Son los dos chars
				mid = new Attributes(prev.valChar != a1.valChar);
			}
		}
		else if(op.kind==tMOD) {
			//Los dos tienen que ser enteros
			if (prev.type!=Symbol.Types.INT || a1.type!=Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT);
			}
			//Calculo
			mid = new Attributes(prev.valInt % a1.valInt);
		}
	}
	a2=expr_plus(mid)
	{
		return a2;
	}
|
	{
		return prev;
	}
}

Token operador() :
{
	Token output;
}
{
	(output=<tSUMA> | output=<tRESTA> | output=<tMUL> | output=<tDIV> | output=<tOR> | output=<tAND> | output=<tIGUAL> | output=<tMAYOR> | output=<tMAYORI> | output=<tMENOR> | output=<tMENORI> | output=<tDISTINTO> | output=<tMOD>)
	{
		return output;
	}
}

Attributes factor() :
{
	Attributes a = new Attributes();
	Attributes output, data;
	Token t1;
}
{
	t1 = <tNUM>
	{
		output = new Attributes(Integer.parseInt(t1.image));
		System.out.println(output.toString());
		return output;
	}
|	t1 = <tCAD>
	{
		output = new Attributes(t1.image);
		System.out.println(output.toString());
		return output;
	}
|	t1 = <tCH>
	{
		output = new Attributes(t1.image.charAt(1));
		System.out.println(output.toString());
		return output;
	}
|	(t1=<tTRUE> | t1=<tFALSE>)
	{
		output = new Attributes(Boolean.parseBoolean(t1.image));
		System.out.println(output.toString());
		return output;
	}
|	LOOKAHEAD(2)  t1=<tID> <tCOPEN> data=expr(a) <tCCLOSE>
	{
		//Acceder al vector
		try {
			Symbol v = tabla.getSymbol(t1.image);
			//Comprobar que el index es un int
			if (data.type != Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), t1, Symbol.Types.INT);
			}
			//Comprobar que el simbolo es un array
			if (v.type != Symbol.Types.ARRAY) {
				errorSem.deteccion(new TypeErrorException(), t1, Symbol.Types.ARRAY);
				output = new Attributes();
			}
			else {
				//Comprobar que el index es correcto
				if(data.isConstant) {	//Si sabemos el valor...
					if((data.valInt >= ((SymbolArray)v).maxInd) || (data.valInt < ((SymbolArray)v).minInd)) {
						errorSem.deteccion(new IndexOOBException(), t1, data.valInt);
					}
				}
				output = new Attributes(((SymbolArray)v).baseType,((SymbolArray)v).parClass);
			}
			System.out.println(output.toString());
			return output;
		}
		catch(SymbolNotFoundException e) {
			errorSem.deteccion(e, t1);
		}
	
	}
| 	output=inst_char2int()
	{
		System.out.println(output.toString());
		return output;
	}
|	output=inst_int2char()
	{
		System.out.println(output.toString());
		return output;
	}
|	LOOKAHEAD(2)  inst_invocacion()
	{
		//TODO
	}
|	t1=<tID>
	{
		try {
			// Symbol v = tabla.getSymbol(t1.image);
			// if (v.type!=Symbol.Types.INT && v.type!=Symbol.Types.CHAR && v.type!=Symbol.Types.BOOL) {
			// 	errorSem.deteccion(new TypeErrorException(), t1, Symbol.Types.INT, Symbol.Types.CHAR, Symbol.Types.BOOL);
			// }
			// output = new Attributes(v.value);
			// return output;

			//TODO
		}
		catch(SymbolNotFoundException e) {
			errorSem.deteccion(e, t1);
			//TODO: return aqui
		}
	}
|	<tPOPEN> output=expr(a) <tPCLOSE>
	{
		System.out.println(output.toString());
		return output;
	}
|	t1=<tNOT> output=factor()
	{
		if (output.type != Symbol.Types.BOOL) {
			errorSem.deteccion(new TypeErrorException(), t1, Symbol.Types.BOOL);
			return output;
		}
		output.valBool = !output.valBool;
		System.out.println(output.toString());
		return output;
	}
}

void inst_while() :
{
	Attributes a = new Attributes();
}
{
	try {
		<tWHILE> expr(a) <tDO> (instruccion())* <tEND>
	}
	catch(ParseException e) {
		System.out.println(e.toString());
		Token t;
		do {
		  t = getNextToken();
		}
		while (t.kind != tEND);
	}
}
	

