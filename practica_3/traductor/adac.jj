//*****************************************************************
// File:   adac.jj
// Author: Marcos Garralaga (795936), Victor Gallardo (801159)
// Date:   09/03/22
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//*****************************************************************

options {
  //DEBUG_PARSER = true;
}


PARSER_BEGIN(adac)
package traductor;


import lib.errores.ErrorSemantico;
import lib.attributes.Attributes;
import lib.symbolTable.Symbol;
import lib.symbolTable.SymbolArray;
import lib.symbolTable.SymbolFunction;
import lib.symbolTable.SymbolProcedure;
import lib.symbolTable.SymbolBool;
import lib.symbolTable.SymbolChar;
import lib.symbolTable.SymbolInt;
import lib.symbolTable.SymbolString;
import lib.symbolTable.SymbolTable;
import lib.symbolTable.exceptions.IndexOOBException;
import lib.symbolTable.exceptions.AlreadyDefinedSymbolException;
import lib.symbolTable.exceptions.SymbolNotFoundException;
import lib.symbolTable.exceptions.InvocationException;
import lib.symbolTable.exceptions.TypeErrorException;
import lib.symbolTable.exceptions.IndexOOBException;
import lib.symbolTable.exceptions.ContextException;
import java.util.ArrayList;

public class adac {
	static SymbolTable tabla = new SymbolTable();
	static ErrorSemantico errorSem = new ErrorSemantico();

	

//FUNCION QUE CREA EL SIMBOLO CORRESPONDIENTE AL PARAMETRO DE UNA FUNCION.
// DADO UN NOMBRE DIM, TIPO Y SI ES POR REF O POR VAL DEVUELVE EL SIMBOLO
// Si se le indica tambien lo inserta en la tabla

	public static Symbol crearParametro(Token nombre, Attributes dim, Symbol.Types tipo, 
	boolean ref , boolean insertarEnTabla){
		Symbol s = null;
		
		if(dim != null){
			s = new SymbolArray(nombre.image,dim.valInt,tipo);
			if(ref == true){
				s.parClass = Symbol.ParameterClass.REF;
			}
			else{
				s.parClass = Symbol.ParameterClass.VAL;
			}
			s.constant = false;
			if(insertarEnTabla == true){
				try{
					tabla.insertSymbol(s);
				}
				catch(AlreadyDefinedSymbolException e){
					errorSem.deteccion(e,nombre);
				}	
			}
			return s;
		}
		switch (tipo) {
			case INT:
				s = new SymbolInt(nombre.image);
				if(ref == true){
					s.parClass = Symbol.ParameterClass.REF;
				}
				else{
					s.parClass = Symbol.ParameterClass.VAL;
				}
				s.constant = false;
				if(insertarEnTabla == true){
					try{
						tabla.insertSymbol(s);
					}
					catch(AlreadyDefinedSymbolException e){
						errorSem.deteccion(e,nombre);
					}	
				}
				return s;
			
			case BOOL:
				s = new SymbolBool(nombre.image);
				if(ref == true){
					s.parClass = Symbol.ParameterClass.REF;
				}
				else{
					s.parClass = Symbol.ParameterClass.VAL;
				}
				s.constant = false;
				if(insertarEnTabla == true){
					try{
						tabla.insertSymbol(s);
					}
					catch(AlreadyDefinedSymbolException e){
						errorSem.deteccion(e,nombre);
					}	
				}
				return s;
			
			case CHAR:
				s = new SymbolChar(nombre.image);
				if(ref == true){
					s.parClass = Symbol.ParameterClass.REF;
				}
				else{
					s.parClass = Symbol.ParameterClass.VAL;
				}
				s.constant = false;
				if(insertarEnTabla == true){
					try{
						tabla.insertSymbol(s);
					}
					catch(AlreadyDefinedSymbolException e){
						errorSem.deteccion(e,nombre);
					}	
				}
				return s;
			default:
				errorSem.deteccion(new TypeErrorException(), nombre, Symbol.Types.INT,Symbol.Types.CHAR,Symbol.Types.BOOL);
				return null;
		}
		
	}

    public static void main(String[] args) {
    	adac parser;

    	try {
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac(System.in);
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			parser.S(); //invoca símbolo inicial de la gramática
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        }
        catch (ParseException e) {
        	System.err.println("SINT_ERROR: " + e.getMessage());
        } 
    }

}
PARSER_END(adac)
//------------ descripción del AL
SKIP :
{
    " "
| 	"\t"
| 	"\n"
| 	"\r"
|	<"--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}



TOKEN : //-------palabras reservadas e identificadores
{
 	< tBEGIN: "begin" >
 		{
 			//watchedToken.beginline;
			//watchedToken.begincolumn;
 		}
|	< tBOOL: "boolean" >
|	< tCHAR: "character" >
|	< tINT: "integer">
|	< tIF:   "if" >
|	< tELSE: "else">
|	< tWHILE: "while" >
|	< tPROCEDURE: "procedure" >
|	< tFUNCTION: "function" >
|	< tIS: "is" >
|	< tRETURN: "return" > 
|	< tDO: "do" >
|	< tEND: "end" >
|	< tTHEN: "then" >
|	< tGET: "get" >
|	< tSKIPLINE: "skip_line" >
|	< tINT2CHAR: "int2char" >
|	< tCHAR2INT: "char2int" >
|	< tPUT : "put" >
|	< tPUTLINE: "put_line">
}


TOKEN :  //-----caracteres , operadores y separadores
{
 	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< tNUM: (<DIGIT>)+ >
|	< tCAD: "\"" (~["\t","\n","\r"])* "\"" >
|	< tCH: "\'" (~["\t","\n","\r"])? "\'" >
|	< tSUMA: "+" > 
|	< tRESTA: "-">
|	< tMUL:	"*" >
|	< tDIV: "div" >
|	< tMOD: "mod">
| 	< tCOMA: ",">
|	< tPCOMA: ";" >
|	< tMENOR: "<" >
|	< tMAYOR: ">" >
|	< tMENORI: "<=" >
|	< tMAYORI: ">=" >
|	< tIGUAL: "=" >
|	< tDISTINTO: "<>" >
|	< tASIGNACION: ":=">
|	< tPOPEN: "(" >
|	< tPCLOSE: ")" >
|	< tCOPEN: "[">
|	< tCCLOSE: "]">
|	< tOR: "or">
|	< tAND: "and" >
|	< tNOT: "not" >
|	< tFALSE: "false">
|	< tTRUE: "true" >
|	< tREF: "ref" >
|	< tVAL: "val" >
|	< tID: (<LETTER>)(("_")?(<LETTER>|<DIGIT>))*("_")? | ("_")((<LETTER>|<DIGIT>)("_")?)* >
}

SPECIAL_TOKEN:
{
	<ERROR:~[]> {
		System.out.println("ERROR LEXICO: (<" + matchedToken.beginLine + ", " + matchedToken.beginColumn
		+ ">): simbolo no reconocido: " + matchedToken.image ) ;
	}
}

//GENERAL

void S () : 
{

}
{
	(instruccion())+ < EOF >
}

void instruccion () :
{
	
}
{
	try {
		LOOKAHEAD(2)  inst_asig() <tPCOMA> 
	|	inst_get() <tPCOMA> 
	|	inst_skip_line() <tPCOMA> 
	|	inst_int2char() <tPCOMA> 
	|	inst_char2int() <tPCOMA> 
	|	inst_escribir() <tPCOMA>  
	| 	inst_escribir_linea() <tPCOMA> 
	|	inst_declaracion_metodo() 
	|	inst_declaracion_variable() <tPCOMA> 
	|	inst_while() 
	| 	inst_seleccion()  
	|	LOOKAHEAD(2)  inst_invocacion() <tPCOMA> 
	|	inst_return() <tPCOMA> 
	}
	catch(ParseException e) {
		System.out.println(e.toString());
		Token t;
		do {
		  t = getNextToken();
		}
		while (t.kind != tPCOMA);
	}
}

Attributes inst_int2char() :
{
	Attributes output;
	Attributes a = new Attributes();
	Token temp;
}
{
	<tINT2CHAR> temp=<tPOPEN> output=expr(a) <tPCLOSE>
	{
		if(output.type != Symbol.Types.INT) {
			errorSem.deteccion(new TypeErrorException(),temp,Symbol.Types.INT);
		}
		return new Attributes((char)(output.valInt));
	}
}

Attributes inst_char2int() :
{
	Attributes output;
	Attributes a = new Attributes();
	Token temp;
}
{
	<tCHAR2INT> temp=<tPOPEN> output=expr(a) <tPCLOSE>
	{
		if(output.type != Symbol.Types.CHAR) {
			errorSem.deteccion(new TypeErrorException(),temp,Symbol.Types.CHAR);
		}
		return new Attributes(Character.getNumericValue(output.valChar));
	}
}

void inst_get() :
{
	Token temp;
}
{
	<tGET> temp=<tPOPEN> list_asignables(temp) <tPCLOSE>
}

void inst_skip_line() :
{

}
{
	<tSKIPLINE> <tPOPEN> <tPCLOSE>
}




//DECLARACION VARIABLES

void inst_declaracion_variable() :
{
	Symbol.Types tipo = Symbol.Types.UNDEFINED;

}
{
	tipo = tipos() variable(tipo) (<tCOMA> variable(tipo))* 
	{
		
		
		
	}
}

Symbol variable(Symbol.Types tipo) :
{
	Token nombre;
	Token dim = null;
	Symbol s;
}
{
	nombre = <tID> (<tCOPEN> dim = <tNUM> <tCCLOSE>)?
	{
		if(dim != null){
			s = new SymbolArray(nombre.image,Integer.parseInt(dim.image),tipo);
			s.constant = false;
			try{
				tabla.insertSymbol(s);
			}
			catch(AlreadyDefinedSymbolException e){
				errorSem.deteccion(e,nombre);
			}	
		
			return s;
	}
	switch (tipo) {
		case INT:
			s = new SymbolInt(nombre.image);
			s.constant = false;
			try{
				tabla.insertSymbol(s);
			}
			catch(AlreadyDefinedSymbolException e){
				errorSem.deteccion(e,nombre);
			}	
			
			return s;
		case BOOL:
			s = new SymbolBool(nombre.image);
			s.constant = false;
			
			try{
				tabla.insertSymbol(s);
			}
			catch(AlreadyDefinedSymbolException e){
				errorSem.deteccion(e,nombre);
			}	
			
			return s;
		
		case CHAR:
			s = new SymbolChar(nombre.image);
			s.constant = false;
			
			try{
				tabla.insertSymbol(s);
			}
			catch(AlreadyDefinedSymbolException e){
				errorSem.deteccion(e,nombre);
			}	
			
			return s;
		default:
			errorSem.deteccion(new TypeErrorException(), nombre, Symbol.Types.INT,Symbol.Types.CHAR,Symbol.Types.BOOL);
			return null;
			break;
		}
		
	
	}
}

//DECLARACION METODO

void inst_declaracion_metodo() :
{
	
}
{
	(inst_declaracion_proc() | inst_declaracion_func())
}



void inst_return() :
{
	Attributes a = new Attributes();
	Attributes a1;
	Token temp;
}
{
	temp=<tRETURN> a1=expr(a)
	{
		Symbol r = tabla.peekStack();
		SymbolFunction d;
		if(r.type != Symbol.Types.FUNCTION) {
			errorSem.deteccion(new ContextException(), temp);
			return;
		}
		else {
			d = ((SymbolFunction)r);
			if(a1.type != d.returnType) {
				errorSem.deteccion(new TypeErrorException(), temp, d.returnType);	
			}
		}
	}
}

void declaracion_variables() :
{
	
}
{
	((inst_declaracion_variable() <tPCOMA>) | inst_declaracion_metodo())*
}

//FUNCION
void inst_declaracion_func() :
{
	Token nombre = null;
	Symbol.Types tipo = Symbol.Types.UNDEFINED;
	ArrayList<Symbol> argums = null;
	Symbol parametro = null;
}
{
	<tFUNCTION> tipo = tipos() nombre = <tID> (argums = argumentos())?
	{
		try{
			SymbolFunction s = new SymbolFunction(nombre.image, argums,tipo); //TODO numero de parametros
			s.constant = true;
			tabla.insertSymbol(s);
			tabla.insertBlock();
			tabla.insertStack(s);
			if(argums.size() != 0){
				for(int i =0; i< argums.size(); i++){
					parametro = argums.get(i);
					tabla.insertSymbol(parametro);
				}
			}
			s.toString();
			tabla.toString();
		}catch(AlreadyDefinedSymbolException e){
			errorSem.deteccion(e, nombre );
		}
	}
	<tIS> declaracion_variables() <tBEGIN> (instruccion())* <tEND>
	{
		tabla.removeBlock();
		tabla.removeStack();
	}
}
//PROCEDIMIENTO
void inst_declaracion_proc():
{
	Token nombre = null;
	ArrayList<Symbol> argums = new ArrayList<Symbol>();
	Symbol parametro = null;

}
{
	<tPROCEDURE> nombre = <tID> (argums = argumentos())?
	{
		try{
			SymbolProcedure s = new SymbolProcedure(nombre.image, argums); //TODO numero de parametros
			s.constant = true;
			tabla.insertSymbol(s);
			tabla.insertBlock();
			tabla.insertStack(s);
			if(argums.size() != 0){
				for(int i =0; i< argums.size(); i++){
					parametro = argums.get(i);
					tabla.insertSymbol(parametro);
				}
			}
			

		}catch(AlreadyDefinedSymbolException e){
			errorSem.deteccion(e, nombre );
		}
	}
	<tIS> declaracion_variables() <tBEGIN> (instruccion())* <tEND>
	{
		tabla.removeBlock();
		tabla.removeStack();
	}
}


void inst_escribir():
{
	ArrayList<Attributes> lista = new ArrayList<Attributes>();
	Token temp;
}
{
	<tPUT> temp=<tPOPEN> lista=list_expr() <tPCLOSE>
	{
		for(Attributes a: lista) {
			if(a.type!=Symbol.Types.INT && a.type!=Symbol.Types.BOOL && a.type!=Symbol.Types.CHAR && a.type!=Symbol.Types.STRING) {
				errorSem.deteccion(new TypeErrorException(), temp, Symbol.Types.INT,Symbol.Types.BOOL,Symbol.Types.CHAR,Symbol.Types.STRING);
			}
		}
	}
}

void inst_escribir_linea():
{

}
{
	<tPUTLINE> <tPOPEN> (list_expr())? <tPCLOSE>
}

void inst_seleccion():
{
	Attributes a = new Attributes();
	Attributes condition = new Attributes();
	Token cond ;

}
{
	try {
		cond = <tIF> condition = expr(a) <tTHEN> (instruccion())* masIf() <tEND>{
			if(condition.type != Symbol.Types.BOOL){
				errorSem.deteccion(new TypeErrorException(),cond,Symbol.Types.BOOL);
			}
		}
	}
	catch(ParseException e) {
		System.out.println(e.toString());
		Token t;
		do {
		  t = getNextToken();
		}
		while (t.kind != tEND);
	}
}

void masIf() :
{

}
{
	(<tELSE> (instruccion())*)?	 // cadena vacía
}
// Regla relativa a los argumentos que se le pasa a una función
ArrayList<Symbol> argumentos() :
{
	ArrayList<Symbol> parametros = new ArrayList<Symbol>();
}
{
	<tPOPEN> (parametros = list_params())? <tPCLOSE>
	{
		return parametros;
	}
}
//Función que junta todos los parametros de una declaración y los devuelve en una lista.
ArrayList<Symbol> list_params():
{
	ArrayList<Symbol> primer_parametro = new ArrayList<Symbol>();
	ArrayList<Symbol> resto_parametros = new ArrayList<Symbol>();
}
{
	primer_parametro = parametro() resto_parametros=list_params_plus()
	{
		primer_parametro.addAll(resto_parametros);
		return primer_parametro;
	}
}

ArrayList<Symbol> list_params_plus():
{
	ArrayList<Symbol> parametro = new ArrayList<Symbol>();
	ArrayList<Symbol> resto_parametros = new ArrayList<Symbol>();
}
{
	<tPCOMA>  parametro = parametro() resto_parametros=list_params_plus()
	{
		parametro.addAll(resto_parametros);
		return parametro;
	}
|	{
		return parametro;
	}
}






// Funcion que devuelve una lista de simbolos que corresponden a una parte de los parametros de 
// un método. Esta función devuelve un único parámetro
// o junta varios parametros declarados del tipo ref/val i,j,k...
ArrayList<Symbol> parametro():
{
	ArrayList<Symbol> lista_parametros = new ArrayList<Symbol>();
	Attributes a = null;

	ArrayList<Symbol> resto_parametros = new ArrayList<Symbol>();

	Token nombre = null;
	Attributes dim = null;
	Symbol s = null;
	Symbol.Types tipo;
}
{
	<tREF> tipo = tipos() nombre = <tID> (<tCOPEN> dim = expr(a) <tCCLOSE>)? 
	{
		//Creo la lista con el parametro y el resto de parametros en caso de que haya mas parametros

		//Para ello primero creo el simbolo del parametro. IGUAL QUE DEFINICION DE VARIABLES
		
		s = crearParametro(nombre,dim,tipo,true,false);
		lista_parametros.add(s); // se añade el parametro


	}
	resto_parametros = masParametros(tipo,true)
	{
		lista_parametros.addAll(resto_parametros);
		return lista_parametros;
	}

|	<tVAL> tipo = tipos() nombre = <tID> (<tCOPEN> dim = expr(a) <tCCLOSE>)? 
	{
		s = crearParametro(nombre,dim,tipo,false,false);
		lista_parametros.add(s); // se añade el parametro
	}


	resto_parametros = masParametros(tipo,false)
	{
		lista_parametros.addAll(resto_parametros);
		return lista_parametros;
	}
}


ArrayList<Symbol> masParametros(Symbol.Types tipo, boolean ref) :
{
	ArrayList<Symbol> resto_parametros = new ArrayList<Symbol>();
	Token nombre = null;
	Attributes dim = null;
	Attributes a = null;
	Symbol s = null;
}
{
	<tCOMA> nombre = <tID> (<tCOPEN> dim = expr(a) <tCCLOSE>)? masParametros(tipo,ref)
	{
		// Crea un (o varios) parametro tanto por referencia como por valor( según se le haya pasado), y 
		// lo devuelve en una lista.
		s = crearParametro(nombre,dim,tipo,ref,false);
		resto_parametros.add(s); // se añade el parametro
		return resto_parametros;

	}
|	{
		return resto_parametros;
	}
}


Symbol.Types tipos():
{

}
{
	<tINT>
	{
	return Symbol.Types.INT;
	}
| 	<tCHAR>
	{
	return Symbol.Types.CHAR;
	}
| 	<tBOOL>
	{
	return Symbol.Types.BOOL;
	}
}

Attributes inst_invocacion() :
{
	Token t1, temp;
	ArrayList<Attributes> params = new ArrayList<Attributes>();
}
{
	t1=<tID> temp=<tPOPEN> (params=list_expr())? <tPCLOSE>
	{
		// System.out.println("Invocacion con: ");
		// for (Attributes a : params) {
		// 	System.out.print("    "+a.toString());
	 	// }
		// System.out.println();

		//Obtener simbolo
		try {
			Symbol v = tabla.getSymbol(t1.image);
			//Comprobar que el simbolo es una funcion
			if (v.type == Symbol.Types.FUNCTION) {
				SymbolFunction f = ((SymbolFunction)v);
				Symbol mainProg = tabla.getLastStack();
				if ((mainProg.type==Symbol.Types.FUNCTION) && (((SymbolFunction)mainProg)==f)) {
					errorSem.deteccion(new ContextException(),t1);
					return new Attributes(f.returnType,Symbol.ParameterClass.NONE);
				}
				if(params.size()!=f.parList.size()) {
					errorSem.deteccion(new InvocationException(), t1, "Nº de parametros incorrecto");
				}
				else {
					for (int i = 0; i<params.size(); i++) {
						if(params.get(i).type != f.parList.get(i).type) {
							errorSem.deteccion(new TypeErrorException(), temp, f.parList.get(i).type);
						}
						if(params.get(i).type==Symbol.Types.ARRAY && f.parList.get(i).type==Symbol.Types.ARRAY) {
							if ((params.get(i).tam != ((SymbolArray)f.parList.get(i)).maxInd-((SymbolArray)f.parList.get(i)).minInd)) {
								errorSem.deteccion(new InvocationException(), t1, "El vector no tiene el tamaño correcto");
							}
							if(params.get(i).baseType != ((SymbolArray)f.parList.get(i)).baseType) {
								errorSem.deteccion(new InvocationException(), t1, "El vector no tiene el mismo tipo");
							}
						}
						// Si el parametro declarado es por ref y el segundo no es asignable, salta error.
						if((f.parList.get(i).parClass == Symbol.ParameterClass.REF) && (params.get(i).parClass!=Symbol.ParameterClass.REF)) {
							errorSem.deteccion(new InvocationException(), t1, "La clase del parametro es incorrecta");
						}
					}
				}
				return new Attributes(f.returnType,Symbol.ParameterClass.NONE);
			}
			else if (v.type == Symbol.Types.PROCEDURE) {
				SymbolProcedure f = ((SymbolProcedure)v);
				Symbol mainProg = tabla.getLastStack();
				if ((mainProg.type==Symbol.Types.PROCEDURE) && (((SymbolProcedure)mainProg)==f)) {
					errorSem.deteccion(new ContextException(),t1);
					return new Attributes(Symbol.Types.UNDEFINED,Symbol.ParameterClass.NONE);
				}
				if(params.size()!=f.parList.size()) {
					errorSem.deteccion(new InvocationException(), t1, "Nº de parametros incorrecto");
				}
				else {
					for (int i = 0; i<params.size(); i++) {
						if(params.get(i).type != f.parList.get(i).type) {
							errorSem.deteccion(new TypeErrorException(), temp, f.parList.get(i).type);
						}
						if(params.get(i).type==Symbol.Types.ARRAY && f.parList.get(i).type==Symbol.Types.ARRAY) {
							if ((params.get(i).tam != ((SymbolArray)f.parList.get(i)).maxInd-((SymbolArray)f.parList.get(i)).minInd)) {
								errorSem.deteccion(new InvocationException(), t1, "El vector no tiene el tamaño correcto");
							}
							if(params.get(i).baseType != ((SymbolArray)f.parList.get(i)).baseType) {
								errorSem.deteccion(new InvocationException(), t1, "El vector no tiene el mismo tipo");
							}
						}
						// Si el parametro declarado es por ref y el segundo no es asignable, salta error.
						if((f.parList.get(i).parClass == Symbol.ParameterClass.REF) && (params.get(i).parClass!=Symbol.ParameterClass.REF)) {
							errorSem.deteccion(new InvocationException(), t1, "La clase del parametro es incorrecta");
						}
					}
				}
				return new Attributes(Symbol.Types.UNDEFINED,Symbol.ParameterClass.NONE);
			}
			else {
				errorSem.deteccion(new TypeErrorException(), t1, Symbol.Types.FUNCTION, Symbol.Types.PROCEDURE);
				return new Attributes();
			}
		}
		catch(SymbolNotFoundException e) {
			errorSem.deteccion(e, t1);
		}
	}
}

void list_asignables(Token temp) :
{
	Symbol a1;
}
{
	a1=asignable() list_asignables_plus()
	{
		if(a1.type!=Symbol.Types.CHAR && a1.type!=Symbol.Types.INT) {
			errorSem.deteccion(new TypeErrorException(), temp, Symbol.Types.INT, Symbol.Types.CHAR);
		}
	}
}

void list_asignables_plus() :
{
	Symbol a1;
	Token temp;
}
{
	temp=<tCOMA> a1=asignable() list_asignables_plus()
	{
		if(a1.type!=Symbol.Types.CHAR && a1.type!=Symbol.Types.INT) {
			errorSem.deteccion(new TypeErrorException(), temp, Symbol.Types.INT, Symbol.Types.CHAR);
		}
	}
|	{ }
}

ArrayList<Attributes> list_expr() :
{
	Attributes a = new Attributes();
	Attributes a1;
	ArrayList<Attributes> other;
}
{
	a1=expr(a) other=list_expr_plus()
	{
		other.add(0, a1);
		return other;
	}
}

ArrayList<Attributes> list_expr_plus() :
{
	Attributes a = new Attributes();
	Attributes a1;
	ArrayList<Attributes> other;
}
{
	<tCOMA> a1=expr(a) other=list_expr_plus()
	{
		other.add(0, a1);
		return other;
	}
|	
	{
		return new ArrayList<Attributes>();
	}
}

//ASIGNACIONES

void inst_asig() :
{
	Symbol asig = null;
	Attributes expr = null;
	Attributes a = new Attributes();
	Token temp;
}
{
	asig = asignable() temp=<tASIGNACION> expr = expr(a)
	{
		if(asig.constant){
			System.err.println("Error: " + asig.name + "es una cte. usada como variable");
		}
		else{
			if ((asig.type != expr.type) && (asig.type != Symbol.Types.ARRAY)){ // SE COMPRUEBA QUE EL ASIGNABLE Y LA EXPRESION A ASIGNAR SEAN DEL MISMO TIPO
				errorSem.deteccion(new TypeErrorException(), temp, asig.type);
			}
			else{
				if(asig.type == Symbol.Types.ARRAY){

				}
				else if(asig.type == Symbol.Types.INT){
					SymbolInt s = (SymbolInt)asig;
					s.value = expr.valInt;
				}
				else if(asig.type == Symbol.Types.CHAR){
					SymbolChar s = (SymbolChar)asig;
					s.value = expr.valChar;
				}
				else if(asig.type == Symbol.Types.BOOL){
					SymbolBool s = (SymbolBool)asig;
					s.value = expr.valBool;
				}
			}
		}
	}
}


// Si el asignable existe devuelve el asignable correspondiente de la tabla de simbolos, 
// si no devuelve null.
Symbol asignable() :
{
	Token nombre = null;
	Symbol output = null;
	Attributes expr = null;
	Attributes a = new Attributes();
}
{
	LOOKAHEAD(2)  nombre = <tID> <tCOPEN> expr = expr(a) <tCCLOSE>
	{
		try{
			//buscamos el simbolo asignable en la tabla de simbolos
			output = tabla.getSymbol(nombre.image);
			// Se mira si el vector es de tipo array
			if(output.type != Symbol.Types.ARRAY) {
				errorSem.deteccion(new TypeErrorException(), nombre, Symbol.Types.ARRAY);
			}
			if(expr.type != Symbol.Types.INT){ // se mira si no se indexa con entero
				errorSem.deteccion(new TypeErrorException(), nombre, Symbol.Types.INT);
			}
			else{
				if(expr.valInt < ((SymbolArray)output).minInd || expr.valInt >= ((SymbolArray)output).maxInd){
					errorSem.deteccion(new IndexOOBException(),nombre, expr.valInt);
				}
			}
			if(((SymbolArray)output).baseType == Symbol.Types.INT) {
				output = new SymbolInt("");
			}
			else if(((SymbolArray)output).baseType == Symbol.Types.CHAR) {
				output = new SymbolChar("");
			}
		}catch(SymbolNotFoundException e){
			errorSem.deteccion(e,nombre);	
		}
		return output;
	}
|	LOOKAHEAD(2)  nombre = <tID>
	{
		try{ 
			//buscamos el simbolo asignable en la tabla de simbolos
			output = tabla.getSymbol(nombre.image);
		}catch(SymbolNotFoundException e){
			errorSem.deteccion(e,nombre);
		}
		return output;
	}	
}

Attributes expr(Attributes prev) :
{
	Attributes a = new Attributes();
	Attributes a1,a2;
}
{
  	a1=factor() a2=expr_plus(a1)
	{
		return a2;
	}
}

Attributes expr_plus(Attributes prev) :
{
	Attributes a1, a2;
	Attributes mid = new Attributes();
	Token op;
}
{
	op=operador() a1=factor()
	{
		if(op.kind==tSUMA) {
			//Los dos tienen que ser enteros
			if (prev.type!=Symbol.Types.INT || a1.type!=Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT);
			}
			//Calculo
			mid = new Attributes(prev.valInt);
		}
		else if(op.kind==tRESTA) {
			//Los dos tienen que ser enteros
			if (prev.type!=Symbol.Types.INT || a1.type!=Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT);
			}
			//Calculo
			mid = new Attributes(prev.valInt);
		}
		else if(op.kind==tMUL) {
			//Los dos tienen que ser enteros
			if (prev.type!=Symbol.Types.INT || a1.type!=Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT);
			}
			//Calculo
			mid = new Attributes(prev.valInt);
		}
		else if(op.kind==tDIV) {
			//Los dos tienen que ser enteros
			if (prev.type!=Symbol.Types.INT || a1.type!=Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT);
			}
			//Calculo
			mid = new Attributes(prev.valInt);
		}
		else if(op.kind==tOR) {
			//Los dos tienen que ser booleanos
			if (prev.type!=Symbol.Types.BOOL || a1.type!=Symbol.Types.BOOL) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.BOOL);
			}
			//Calculo
			mid = new Attributes(true);
		}
		else if(op.kind==tAND) {
			//Los dos tienen que ser booleanos
			if (prev.type!=Symbol.Types.BOOL || a1.type!=Symbol.Types.BOOL) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.BOOL);
			}
			//Calculo
			mid = new Attributes(true);
		}
		else if(op.kind==tIGUAL) {
			//Los dos tienen que ser enteros o chars
			if (!((prev.type == a1.type) && (prev.type==Symbol.Types.INT || prev.type==Symbol.Types.CHAR || prev.type==Symbol.Types.BOOL))) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (prev.type==Symbol.Types.INT) { //Son los dos enteros
				mid = new Attributes(true);
			}
			else if(prev.type == Symbol.Types.BOOL) { // Son los dos bools
				mid = new Attributes(true);
			}
			else { //Son los dos chars
				mid = new Attributes(true);
			}
		}
		else if(op.kind==tMAYOR) {
			//Los dos tienen que ser enteros o chars
			if (!((prev.type == a1.type) && (prev.type==Symbol.Types.INT || prev.type==Symbol.Types.CHAR))) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (prev.type==Symbol.Types.INT) { //Son los dos enteros
				mid = new Attributes(true);
			}
			else { //Son los dos chars
				mid = new Attributes(true);
			}
		}
		else if(op.kind==tMAYORI) {
			//Los dos tienen que ser enteros o chars
			if (!((prev.type == a1.type) && (prev.type==Symbol.Types.INT || prev.type==Symbol.Types.CHAR))) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (prev.type==Symbol.Types.INT) { //Son los dos enteros
				mid = new Attributes(true);
			}
			else { //Son los dos chars
				mid = new Attributes(true);
			}
		}
		else if(op.kind==tMENOR) {
			//Los dos tienen que ser enteros o chars
			if (!((prev.type == a1.type) && (prev.type==Symbol.Types.INT || prev.type==Symbol.Types.CHAR))) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (prev.type==Symbol.Types.INT) { //Son los dos enteros
				mid = new Attributes(true);
			}
			else { //Son los dos chars
				mid = new Attributes(true);
			}
		}
		else if(op.kind==tMENORI) {
			//Los dos tienen que ser enteros o chars
			if (!((prev.type == a1.type) && (prev.type==Symbol.Types.INT || prev.type==Symbol.Types.CHAR))) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (prev.type==Symbol.Types.INT) { //Son los dos enteros
				mid = new Attributes(true);
			}
			else { //Son los dos chars
				mid = new Attributes(true);
			}
		}
		else if(op.kind==tDISTINTO) {
			//Los dos tienen que ser enteros o chars
			if (!((prev.type == a1.type) && (prev.type==Symbol.Types.INT || prev.type==Symbol.Types.CHAR || prev.type==Symbol.Types.BOOL))) { 
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT,Symbol.Types.CHAR);
			}
			//Calculo
			if (prev.type==Symbol.Types.INT) { //Son los dos enteros
				mid = new Attributes(true);
			}
			else if(prev.type == Symbol.Types.BOOL) { // Son los dos bools
				mid = new Attributes(true);
			}
			else { //Son los dos chars
				mid = new Attributes(true);
			}
		}
		else if(op.kind==tMOD) {
			//Los dos tienen que ser enteros
			if (prev.type!=Symbol.Types.INT || a1.type!=Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), op, Symbol.Types.INT);
			}
			//Calculo
			mid = new Attributes(prev.valInt);
		}
	}
	a2=expr_plus(mid)
	{
		return a2;
	}
|
	{
		return prev;
	}
}

Token operador() :
{
	Token output;
}
{
	(output=<tSUMA> | output=<tRESTA> | output=<tMUL> | output=<tDIV> | output=<tOR> | output=<tAND> | output=<tIGUAL> | output=<tMAYOR> | output=<tMAYORI> | output=<tMENOR> | output=<tMENORI> | output=<tDISTINTO> | output=<tMOD>)
	{
		return output;
	}
}

Attributes factor() :
{
	Attributes a = new Attributes();
	Attributes output, data;
	Token t1;
}
{
	t1 = <tNUM>
	{
		output = new Attributes(Integer.parseInt(t1.image));
		
		return output;
	}
|	t1 = <tCAD>
	{
		output = new Attributes(t1.image);
		
		return output;
	}
|	t1 = <tCH>
	{
		output = new Attributes(t1.image.charAt(1));
		
		return output;
	}
|	(t1=<tTRUE> | t1=<tFALSE>)
	{
		output = new Attributes(Boolean.parseBoolean(t1.image));
		
		return output;
	}
|	LOOKAHEAD(2)  t1=<tID> <tCOPEN> data=expr(a) <tCCLOSE>
	{
		//Acceder al vector
		try {
			Symbol v = tabla.getSymbol(t1.image);
			//Comprobar que el index es un int
			if (data.type != Symbol.Types.INT) {
				errorSem.deteccion(new TypeErrorException(), t1, Symbol.Types.INT);
			}
			//Comprobar que el simbolo es un array
			if (v.type != Symbol.Types.ARRAY) {
				errorSem.deteccion(new TypeErrorException(), t1, Symbol.Types.ARRAY);
				output = new Attributes();
			}
			else {
				//Comprobar que el index es correcto
				if(data.isConstant) {	//Si sabemos el valor...
					if((data.valInt >= ((SymbolArray)v).maxInd) || (data.valInt < ((SymbolArray)v).minInd)) {
						errorSem.deteccion(new IndexOOBException(), t1, data.valInt);
					}
				}
				output = new Attributes(((SymbolArray)v).baseType, Symbol.ParameterClass.REF);
			}
			
			return output;
		}
		catch(SymbolNotFoundException e) {
			errorSem.deteccion(e, t1);
		}
	
	}
| 	output=inst_char2int()
	{
		
		return output;
	}
|	output=inst_int2char()
	{
		
		return output;
	}
|	LOOKAHEAD(2)  output=inst_invocacion()
	{
		return output;
	}
|	t1=<tID>
	{
		try {
			Symbol v = tabla.getSymbol(t1.image);
			if (v.type!=Symbol.Types.INT && v.type!=Symbol.Types.CHAR && v.type!=Symbol.Types.BOOL) {
				errorSem.deteccion(new TypeErrorException(), t1, Symbol.Types.INT, Symbol.Types.CHAR, Symbol.Types.BOOL);
			}
			if (v.type == Symbol.Types.INT) {
				output = new Attributes(((SymbolInt)v).value, Symbol.ParameterClass.REF);
			}
			else if (v.type == Symbol.Types.CHAR) {
				output = new Attributes(((SymbolChar)v).value, Symbol.ParameterClass.REF);
			}
			else if (v.type == Symbol.Types.BOOL) {
				output = new Attributes(((SymbolBool)v).value, Symbol.ParameterClass.REF);
			}
			else if (v.type == Symbol.Types.ARRAY) {
				output = new Attributes(((SymbolArray)v).baseType, ((SymbolArray)v).maxInd-((SymbolArray)v).minInd);
			}
			else {
				output = new Attributes();
			}
			return output;

		}
		catch(SymbolNotFoundException e) {
			errorSem.deteccion(e, t1);
			//TODO: return aqui
		}
	}
|	<tPOPEN> output=expr(a) <tPCLOSE>
	{
		
		return output;
	}
|	t1=<tNOT> output=factor()
	{
		if (output.type != Symbol.Types.BOOL) {
			errorSem.deteccion(new TypeErrorException(), t1, Symbol.Types.BOOL);
			return output;
		}
		output.valBool = !output.valBool;
		
		return output;
	}
}

void inst_while() :
{
	Attributes a = new Attributes();
	Attributes condition = new Attributes();
	Token buc;
}
{
	try {
		buc = <tWHILE> condition = expr(a) <tDO> (instruccion())* <tEND>
		{
			if(condition.type != Symbol.Types.BOOL){
				System.err.println("Tipo que me llega: "+condition.type);
				errorSem.deteccion(new TypeErrorException(),buc,Symbol.Types.BOOL);
			}
		}
	}
	catch(ParseException e) {
		System.out.println(e.toString());
		Token t;
		do {
		  t = getNextToken();
		}
		while (t.kind != tEND);
	}
}
	

