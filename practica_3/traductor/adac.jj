//*****************************************************************
// File:   adac.jj
// Author: Marcos Garralaga (795936), Victor Gallardo (801159)
// Date:   09/03/22
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//*****************************************************************

options {
//    DEBUG_PARSER = true;
}


PARSER_BEGIN(adac)
package traductor;


import lib.*;

public class adac {
	public class Atributos {
		Symbol.Types tipo;
		String id;
		int dim;
	}
	static SymbolTable tabla = new symbolTable();
	static ErrorSemantico errorSem = new ErrorSemantico();
    public static void main(String[] args) {
    	adac parser;

    	try {
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac(System.in);
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			parser.S(); //invoca símbolo inicial de la gramática
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        }
        catch (ParseException e) {
        	System.err.println("SINT_ERROR: " + e.getMessage());
        } 
    }
}
PARSER_END(adac)
//------------ descripción del AL
SKIP :
{
    " "
| 	"\t"
| 	"\n"
| 	"\r"
|	<"--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}



TOKEN : //-------palabras reservadas e identificadores
{
 	< tBEGIN: "begin" >
 		{
 			//watchedToken.beginline;
			//watchedToken.begincolumn;
 		}
|	< tBOOL: "boolean" >
|	< tCHAR: "character" >
|	< tINT: "integer">
|	< tIF:   "if" >
|	< tELSE: "else">
|	< tWHILE: "while" >
|	< tPROCEDURE: "procedure" >
|	< tFUNCTION: "function" >
|	< tIS: "is" >
|	< tRETURN: "return" > 
|	< tDO: "do" >
|	< tEND: "end" >
|	< tTHEN: "then" >
|	< tGET: "get" >
|	< tSKIPLINE: "skip_line" >
|	< tINT2CHAR: "int2char" >
|	< tCHAR2INT: "char2int" >
|	< tPUT : "put" >
|	< tPUTLINE: "put_line">
}


TOKEN :  //-----caracteres , operadores y separadores
{
 	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< tNUM: (<DIGIT>)+ >
|	< tCAD: "\"" (~["\t","\n","\r"])* "\"" >
|	< tCH: "\'" (~["\t","\n","\r"])? "\'" >
|	< tSUMA: "+" > 
|	< tRESTA: "-">
|	< tMUL:	"*" >
|	< tDIV: "div" >
|	< tMOD: "mod">
| 	< tCOMA: ",">
|	< tPCOMA: ";" >
|	< tMENOR: "<" >
|	< tMAYOR: ">" >
|	< tMENORI: "<=" >
|	< tMAYORI: ">=" >
|	< tIGUAL: "=" >
|	< tDISTINTO: "<>" >
|	< tASIGNACION: ":=">
|	< tPOPEN: "(" >
|	< tPCLOSE: ")" >
|	< tCOPEN: "[">
|	< tCCLOSE: "]">
|	< tOR: "or">
|	< tAND: "and" >
|	< tNOT: "not" >
|	< tFALSE: "false">
|	< tTRUE: "true" >
|	< tREF: "ref" >
|	< tVAL: "val" >
|	< tID: (<LETTER>)(("_")?(<LETTER>|<DIGIT>))*("_")? | ("_")((<LETTER>|<DIGIT>)("_")?)* >
}

SPECIAL_TOKEN:
{
	<ERROR:~[]> {
		System.out.println("ERROR LEXICO: (<" + matchedToken.beginLine + ", " + matchedToken.beginColumn
		+ ">): simbolo no reconocido: " + matchedToken.image ) ;
	}
}

//GENERAL

void S () : 
{

}
{
	(instruccion())+ < EOF >
}

void instruccion () :
{

}
{
	try {
		LOOKAHEAD(2)  inst_asig() <tPCOMA>
	|	inst_get() <tPCOMA>
	|	inst_skip_line() <tPCOMA>
	|	inst_int2char() <tPCOMA>
	|	inst_char2int() <tPCOMA>
	|	inst_escribir() <tPCOMA> 
	| 	inst_escribir_linea() <tPCOMA>
	|	inst_declaracion_metodo()
	|	inst_declaracion_variable() <tPCOMA>
	|	inst_while()
	| 	inst_seleccion() 
	|	LOOKAHEAD(2)  inst_invocacion() <tPCOMA>
	|	inst_return() <tPCOMA>
	}
	catch(ParseException e) {
		System.out.println(e.toString());
		Token t;
		do {
		  t = getNextToken();
		}
		while (t.kind != tPCOMA);
	}
}

void inst_int2char() :
{

}
{
	<tINT2CHAR> <tPOPEN> expr() <tPCLOSE>
}

void inst_char2int() :
{

}
{
	<tCHAR2INT> <tPOPEN> expr() <tPCLOSE>
}

void inst_get() :
{

}
{
	<tGET> <tPOPEN> (list_asignables())+ <tPCLOSE>
}

void inst_skip_line() :
{

}
{
	<tSKIPLINE> <tCOPEN> <tCCLOSE>
}

//DECLARACION VARIABLES

void inst_declaracion_variable() :
{
	Symbol.Types tipo = Symbol.Types.UNDEFINED;

}
{
	tipo = tipos() variable(tipo) (<tCOMA> variable(tipo))* 
	{
		
	
		
	}
}

Atributos variable(SymbolType tipo) :
{
	Token nombre;
	Token dim;
	

}
{
	nombre = <tID> (<tCOPEN> dim = <tNUM> <tCCLOSE>)?
	{


	if(dim != null){
		SymbolArray s = new SymbolArray(nombre.image,dim.image,tipo);
	}
	if (tipo == Symbol.Types.INT) {		//INT
		SymbolInt s = new SymbolInt(nombre.image);
	}
	else if (tipo == Symbol.Types.BOOL) {
		SymbolBool s = new SymbolBool(nombre.image);
	}
	else if (tipo == Symbol.Types.CHAR) {
		SymbolChar s = new SymbolChar(nombre.image);
	}
	s.constant = false;
	try{
		tabla.insert(s);
	}
	catch(AlreadyDefinedSymbolException e){
		System.err.println("Error: " + nombre.image + "ya esta declarado");
	}












	if(expr_devuelta != null){
		// EN CASO DE VECTOR
		if(expr_devuelta.type != Symbol.Types.INT){ // EXPRESION TIENE QUE TENER UN VALOR NUMERICO
			errorSem.deteccion(new TypeErrorException(), data, Token.Types.INT);
		}else{
			caracteristicas.dim = expr_devuelta.dim;	
		}
	
	}
	return caracteristicas;
	}
}

//DECLARACION METODO

void inst_declaracion_metodo() :
{
	
}
{
	(inst_declaracion_proc() | inst_declaracion_func())
}



void inst_return() :
{

}
{
	<tRETURN> expr()
}

void declaracion_variables() :
{
	
}
{
	((inst_declaracion_variable() <tPCOMA>) | inst_declaracion_metodo())*
}

//FUNCION
void inst_declaracion_func() :
{
	Token nombre = null;
	Symbol.Types tipo = Symbol.Types.UNDEFINED;
}
{
	<tFUNCTION> tipo = tipos() nombre = <tID> (argumentos())? <tIS> declaracion_variables() <tBEGIN> (instruccion())* <tEND>
	{
		try{
			SymbolFunction s = new SymbolFunction(nombre.image,null,tipo);
			s.constant = true ;
			tabla.insertSymbol(s);	
			tabla.insertBlock();
		}catch(AlreadyDefinedSymbolException e){
			ErrorSem.deteccion(e, nombre );
		}
	}
}
//PROCEDIMIENTO
void inst_declaracion_proc():
{
	Token nombre = null ;
}
{
	<tPROCEDURE> nombre = <tID> (argumentos())? <tIS> declaracion_variables() <tBEGIN> (instruccion())* <tEND>
	{
		try{
			SymbolProcedure s = new SymbolProcedure(nombre.image);
			s.constant = true;
			tabla.insertSymbol(s);	
			tabla.insertBlock();
		}catch(AlreadyDefinedSymbolException e){
			ErrorSem.deteccion(e, nombre );
		}
	}
}


void inst_escribir():
{

}
{
	<tPUT> <tPOPEN> (list_expr())? <tPCLOSE>	
}

void inst_escribir_linea():
{

}
{
	<tPUTLINE> <tPOPEN> (list_expr())? <tPCLOSE>
}

void inst_seleccion():
{

}
{
	try {
		<tIF> expr() <tTHEN> (instruccion())* masIf() <tEND>
	}
	catch(ParseException e) {
		System.out.println(e.toString());
		Token t;
		do {
		  t = getNextToken();
		}
		while (t.kind != tEND);
	}
}

void masIf():
{

}
{
	(<tELSE> (instruccion())*)?	 // cadena vacía
}
// Regla relativa a los argumentos que se le pasa a una función
void argumentos() :
{

}
{
	<tPOPEN> (list_params())? <tPCLOSE>
}

void list_params():
{

}
{
	parametro() (<tPCOMA> parametro())*
}

void parametro():
{

}
{
	<tREF> tipos() <tID> (<tCOPEN> expr() <tCCLOSE>)? (<tCOMA> <tID> (<tCOPEN> expr() <tCCLOSE>)?)*
|	<tVAL> tipos() <tID> (<tCOPEN> expr() <tCCLOSE>)? (<tCOMA> <tID> (<tCOPEN> expr() <tCCLOSE>)?)*
}


Symbol.Types tipos():
{

}
{
	<tINT>
	{
	return Symbol.Types.INT;
	}
| 	<tCHAR>
	{
	return Symbol.Types.CHAR;
	}
| 	<tBOOL>
	{
	return Symbol.Types.BOOL;
	}
}

void inst_invocacion() :
{

}
{
	<tID> <tPOPEN> (list_expr())? <tPCLOSE>
}

void list_asignables() :
{

}
{
	asignable() (<tCOMA> asignable())*
}

void list_expr() :
{

}
{
	expr() (<tCOMA> expr())*
}

//ASIGNACIONES

void inst_asig() :
{

}
{
	asignable() <tASIGNACION> expr()
}


void asignable() :
{

}
{
	LOOKAHEAD(2)  <tID> <tCOPEN> expr() <tCCLOSE>
|	LOOKAHEAD(2)  <tID>	
}

Symbol expr() :
{
	Symbol output;
}
{
  	factor()  ( operador() factor() )*
}

void operador() :
{

}
{
	<tSUMA> | <tRESTA> | <tMUL> | <tDIV> | <tOR> | <tAND> | <tIGUAL> | <tMAYOR> | <tMAYORI> | <tMENOR> | <tMENORI> | <tDISTINTO> | <tMOD>
}

Symbol factor() :
{
	Symbol output, data;
	Token t1;
}
{
	t1 = <tNUM>
	{
	output = new SymbolInt(Integer.parseInt(t1.image));
	return output;
	}
|	t1 = <tCAD>
	{
	output = new SymbolString("",t1.image,Symbol.ParameterClass.NONE);
	return output;
	}
	t1 = <tCH>
	{
	output = new SymbolChar(t1.image);
	return output;
	}
|	(t1=<tTRUE> | t1=<tFALSE>)
	{
	output = new SymbolBool(Boolean.parseBoolean(t1.image));
	return output;
	}
|	LOOKAHEAD(2)  t1=<tID> <tCOPEN> data=expr() <tCCLOSE>
	{
	//Acceder al vector
	try {
		output = tabla.getSymbol(t1.image);
	}
	catch(SymbolNotFoundException e) {
		errorSem.deteccion(e, t1);
	}
	//Comprobar que el index es un int
	if (data.type != Symbol.Types.INT) {
		errorSem.deteccion(new TypeErrorException(), data, Token.Types.INT);
	}
	//TODO: Acceder a la componente del vector (tirar error IndexOOB si no existe)
	}
| 	inst_char2int()
|	inst_int2char()
|	LOOKAHEAD(2)  inst_invocacion()
|	<tID>		//a
|	<tPOPEN> expr() <tPCLOSE>		//(expr)
|	<tNOT> factor()		//not expr
	{
	//TODO: Checkear que factor es un bool, actualizar su valor
	}
}

void inst_while() :
{

}
{
	try {
		<tWHILE> expr() <tDO> (instruccion())* <tEND>
	}
	catch(ParseException e) {
		System.out.println(e.toString());
		Token t;
		do {
		  t = getNextToken();
		}
		while (t.kind != tEND);
	}
}
	

